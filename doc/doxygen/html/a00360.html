<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>dune-istl: Dune Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dune Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00366"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00366.html">Amg</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">base_array_unmanaged</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple array container for objects of type B.  <a href="a00036.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">base_array_window</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <a class="el" href="a00036.html" title="A simple array container for objects of type B.">base_array_unmanaged</a> by functions to manipulate.  <a href="a00037.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">base_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container extends <a class="el" href="a00036.html" title="A simple array container for objects of type B.">base_array_unmanaged</a> by memory management with the usual copy semantics providing the full range of copy constructor, destructor and assignment operators.  <a href="a00035.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">compressed_base_array_unmanaged</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple array container with non-consecutive index set.  <a href="a00063.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">BCRSMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse block matrix with compressed row storage.  <a href="a00040.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">BDMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-diagonal matrix.  <a href="a00041.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">BTDMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-tridiagonal matrix.  <a href="a00048.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">block_vector_unmanaged</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unmanaged vector of blocks.  <a href="a00044.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">BlockVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of blocks with memory management.  <a href="a00046.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">BlockVectorWindow</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">compressed_block_vector_unmanaged</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">CompressedBlockVectorWindow</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">DiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal matrix of static size.  <a href="a00102.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">DiagonalMatrixWrapper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">DiagonalRowVectorConst</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">DiagonalRowVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">const_reference&lt; DiagonalRowVector&lt; K, n &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">const_reference&lt; DiagonalRowVectorConst&lt; K, n &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">mutable_reference&lt; DiagonalRowVector&lt; K, n &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">mutable_reference&lt; DiagonalRowVectorConst&lt; K, n &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">ContainerWrapperIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for sparse vector-like containers.  <a href="a00092.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">BL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compile-time parameter for block recursion depth  <a href="a00043.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">algmeta_btsolve</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">algmeta_btsolve&lt; 0, withdiag, withrelax &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">algmeta_btsolve&lt; 0, withdiag, norelax &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">algmeta_btsolve&lt; 0, nodiag, withrelax &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">algmeta_btsolve&lt; 0, nodiag, norelax &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">algmeta_bdsolve</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">algmeta_bdsolve&lt; 0, withrelax &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">algmeta_bdsolve&lt; 0, norelax &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">algmeta_itsteps</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">algmeta_itsteps&lt; 0 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">MatrixBlockError</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">ILUSubdomainSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class encapsulating common algorithms of <a class="el" href="a00129.html" title="Exact subdomain solver using ILU(p) with appropriate p.">ILU0SubdomainSolver</a> and <a class="el" href="a00130.html">ILUNSubdomainSolver</a>.  <a href="a00131.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">ILU0SubdomainSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact subdomain solver using ILU(p) with appropriate p.  <a href="a00129.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">ILUNSubdomainSolver</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">ISTLError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">derive error class from the base class in common  <a href="a00144.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic dynamic dense matrix.  <a href="a00156.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">MatrixIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the nonzero entries in a sparse matrix.  <a href="a00168.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html">MatrixMarketFormatError</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">mm_multipliers</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html">mm_multipliers&lt; BCRSMatrix&lt; FieldMatrix&lt; B, i, j &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">MatMultMatResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper TMP to get the result type of a sparse matrix matrix multiplication ( <img class="formulaInl" alt="$C=A*B$" src="form_20.png"/>)  <a href="a00153.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">MatMultMatResult&lt; FieldMatrix&lt; T, n, k &gt;, FieldMatrix&lt; T, k, m &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">MatMultMatResult&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, k &gt;, A &gt;, BCRSMatrix&lt; FieldMatrix&lt; T, k, m &gt;, A1 &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">RedistributeInformation</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00220.html">RedistributeInformation&lt; OwnerOverlapCopyCommunication&lt; T, T1 &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">CommMatrixRowSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to communicate and set the row sizes of a redistributed matrix.  <a href="a00058.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">CommMatrixSparsityPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to communicate and build the sparsity pattern of a redistributed matrix.  <a href="a00059.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">CommPolicy&lt; CommMatrixSparsityPattern&lt; M, I &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">CommMatrixRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for comunicating the matrix entries.  <a href="a00057.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">CommPolicy&lt; CommMatrixRow&lt; M, I &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html">MatrixRowSizeGatherScatter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00160.html">MatrixCopyRowSizeGatherScatter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">MatrixSparsityPatternGatherScatter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">MatrixRowGatherScatter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">CheckIfDiagonalPresent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the a matrix has diagonal values on blocklevel recursion levels.  <a href="a00051.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">CheckIfDiagonalPresent&lt; Matrix, 0, l &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">CheckIfDiagonalPresent&lt; MultiTypeBlockMatrix&lt; T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt;, blocklevel, l &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html">MatrixDimension</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">MatrixDimension&lt; BCRSMatrix&lt; B, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00163.html">MatrixDimension&lt; BCRSMatrix&lt; FieldMatrix&lt; B, n, m &gt;, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html">MatrixDimension&lt; FieldMatrix&lt; K, n, m &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">MatrixDimension&lt; Matrix&lt; FieldMatrix&lt; K, n, m &gt;, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">IsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a type is an ISTL <a class="el" href="a00156.html" title="A generic dynamic dense matrix.">Matrix</a>.  <a href="a00141.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">IsMatrix&lt; DenseMatrix&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">IsMatrix&lt; BCRSMatrix&lt; T, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">NonoverlappingSchwarzOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nonoverlapping operator with communication object.  <a href="a00185.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">NonoverlappingSchwarzScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonoverlapping Scalar Product with communication object.  <a href="a00186.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00227.html">ScalarProductChooser&lt; X, C, SolverCategory::nonoverlapping &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">NonoverlappingBlockPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonoverlapping parallel preconditioner.  <a href="a00183.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">LinearOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear operator.  <a href="a00151.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">AssembledLinearOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear operator exporting itself in matrix form.  <a href="a00034.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">MatrixAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to turn a matrix into a linear operator.  <a href="a00157.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">OverlappingSchwarzInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for <a class="el" href="a00265.html">SuperLU</a> Matrices representing the subdomains.  <a href="a00193.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">AdditiveSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that the tells the schwarz method to be additive.  <a href="a00009.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">MultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative.  <a href="a00180.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html">SymmetricMultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative and symmetric.  <a href="a00282.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">OverlappingAssigner</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">OverlappingAssignerILUBase</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">OverlappingAssigner&lt; ILU0SubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00190.html">OverlappingAssigner&lt; ILUNSubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">AdditiveAdder</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">AdditiveAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">MultiplicativeAdder</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">MultiplicativeAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">AdderSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template meta program for choosing how to add the correction.  <a href="a00002.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">AdderSelector&lt; AdditiveSchwarzMode, X, S &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">AdderSelector&lt; MultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">AdderSelector&lt; SymmetricMultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">IteratorDirectionSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping schwarz.  <a href="a00146.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">IteratorDirectionSelector&lt; T1, T2, false &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html">SeqOverlappingSchwarzApplier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping schwarz.  <a href="a00236.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">SeqOverlappingSchwarzApplier&lt; SeqOverlappingSchwarz&lt; M, X, SymmetricMultiplicativeSchwarzMode, TD, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00238.html">SeqOverlappingSchwarzAssembler</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html">SeqOverlappingSchwarzAssembler&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">SeqOverlappingSchwarzAssembler&lt; SuperLU&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">SeqOverlappingSchwarzAssemblerILUBase</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00240.html">SeqOverlappingSchwarzAssembler&lt; ILU0SubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">SeqOverlappingSchwarzAssembler&lt; ILUNSubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">SeqOverlappingSchwarz</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential overlapping Schwarz preconditioner.  <a href="a00235.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">SeqOverlappingSchwarzDomainSize</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html">SeqOverlappingSchwarzDomainSize&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">OwnerOverlapCopyAttributeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute set for overlapping schwarz.  <a href="a00198.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">IndexInfoFromGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the index distribution.  <a href="a00132.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">OwnerOverlapCopyCommunication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class setting up standard communication for a two-valued attribute set with owner/overlap/copy semantics.  <a href="a00199.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">PropertyMapTypeSelector&lt; Amg::VertexVisitedTag, Amg::PropertiesGraph&lt; G, Amg::VertexProperties, EP, VM, EM &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">CommPolicy&lt; Amg::GlobalAggregatesMap&lt; T, TI &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00247.html">SeqPardiso</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequential Pardiso preconditioner.  <a href="a00247.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">IsDirectSolver&lt; SeqPardiso&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">Preconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matrix free definition of preconditioners.  <a href="a00204.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00250.html">SeqSSOR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SSOR preconditioner.  <a href="a00250.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html">SeqSOR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SOR preconditioner.  <a href="a00249.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html">SeqGS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential Gauss Seidel preconditioner.  <a href="a00231.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00234.html">SeqJac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequential jacobian preconditioner.  <a href="a00234.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">SeqILU0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential ILU0 preconditioner.  <a href="a00232.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">SeqILUn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential ILU(n) preconditioner.  <a href="a00233.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">Richardson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00223.html" title="Richardson preconditioner.">Richardson</a> preconditioner.  <a href="a00223.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00221.html">RedistributeInterface</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html">ScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for scalar product and norm computation.  <a href="a00225.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00226.html">ScalarProductChooser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the approriate scalar product for a solver category.  <a href="a00226.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00248.html">SeqScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for the scalar case.  <a href="a00248.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">ScalarProductChooser&lt; X, C, SolverCategory::sequential &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00230.html">ScaledIdentityMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiple of the identity matrix of static size.  <a href="a00230.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">OverlappingSchwarzOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overlapping schwarz operator.  <a href="a00194.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">OverlappingSchwarzScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product for overlapping schwarz methods.  <a href="a00196.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00228.html">ScalarProductChooser&lt; X, C, SolverCategory::overlapping &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">ParSSOR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel SSOR preconditioner.  <a href="a00203.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">BlockPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block parallel preconditioner.  <a href="a00045.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html">SolverCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categories for the solvers.  <a href="a00262.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">InverseOperatorResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics about the application of an inverse operator.  <a href="a00137.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">InverseOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for all solvers.  <a href="a00136.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">LoopSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioned loop solver.  <a href="a00152.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">GradientSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">gradient method  <a href="a00125.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">CGSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">conjugate gradient method  <a href="a00050.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">BiCGSTABSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bi-conjugate Gradient Stabilized (BiCG-STAB)  <a href="a00042.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">MINRESSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal Residual Method (MINRES)  <a href="a00175.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00222.html">RestartedGMResSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements the Generalized Minimal Residual (GMRes) method  <a href="a00222.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">IsDirectSolver</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">SuperLU</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">SuperLUSolveChooser</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">SuperLUDenseMatChooser</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html">SuperLUQueryChooser</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">QuerySpaceChooser</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">SuperLUDenseMatChooser&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00273.html">SuperLUSolveChooser&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">QuerySpaceChooser&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SuperLu Solver.  <a href="a00266.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">IsDirectSolver&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00274.html">SuperMatrixCreateSparseChooser</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html">SuperMatrixPrinter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html">SuperMatrixCreateSparseChooser&lt; float &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html">SuperMatrixPrinter&lt; float &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">MatrixRowSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to an iterator over all matrix rows.  <a href="a00171.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html">MatrixRowSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to an iterator over an arbitrary subset of matrix rows.  <a href="a00173.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">GetSuperLUType</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">GetSuperLUType&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">GetSuperLUType&lt; float &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">GetSuperLUType&lt; std::complex&lt; double &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">GetSuperLUType&lt; std::complex&lt; float &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00269.html">SuperLUMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for converting an ISTL <a class="el" href="a00156.html" title="A generic dynamic dense matrix.">Matrix</a> into a SsuperLU <a class="el" href="a00156.html" title="A generic dynamic dense matrix.">Matrix</a>.  <a href="a00269.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html">SuperMatrixInitializer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html">SuperLUMatrix&lt; BCRSMatrix&lt; FieldMatrix&lt; B, n, m &gt;, TA &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coverter for <a class="el" href="a00040.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> to <a class="el" href="a00265.html">SuperLU</a> <a class="el" href="a00156.html" title="A generic dynamic dense matrix.">Matrix</a>.  <a href="a00270.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html">SuperMatrixInitializer&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00288.html">VariableBlockVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vector of blocks with different blocksizes.  <a href="a00288.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1a7c58447d9b6097a20628d16c30a0e0"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a1a7c58447d9b6097a20628d16c30a0e0">idxtype</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1d016a8baf2c49b7cf2f4381ac26dae8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00377.html#ga1d016a8baf2c49b7cf2f4381ac26dae8">WithDiagType</a> { <a class="el" href="a00377.html#gga1d016a8baf2c49b7cf2f4381ac26dae8aeee05f0dca4c1c766073efa5a0ce1864">withdiag</a> = 1, 
<a class="el" href="a00377.html#gga1d016a8baf2c49b7cf2f4381ac26dae8a2797146c0f86bb2e64d5dcdd09af49fa">nodiag</a> = 0
 }</td></tr>
<tr class="memitem:ga8d35e02d27a4916c1ba6435f0c2d6ea8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00377.html#ga8d35e02d27a4916c1ba6435f0c2d6ea8">WithRelaxType</a> { <a class="el" href="a00377.html#gga8d35e02d27a4916c1ba6435f0c2d6ea8a6275e2591067a32a12c32074ae56a4ab">withrelax</a> = 1, 
<a class="el" href="a00377.html#gga8d35e02d27a4916c1ba6435f0c2d6ea8a4fcdb30f993f475659d8e031aff47b80">norelax</a> = 0
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d6c22497a84e2ec8803ba78a7e2e988"><td class="memTemplParams" colspan="2">template&lt;class K , class A &gt; </td></tr>
<tr class="memitem:a2d6c22497a84e2ec8803ba78a7e2e988"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a2d6c22497a84e2ec8803ba78a7e2e988">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a00046.html">BlockVector</a>&lt; K, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a2d6c22497a84e2ec8803ba78a7e2e988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <a class="el" href="a00046.html" title="A vector of blocks with memory management.">BlockVector</a> to an output stream.  <a href="#a2d6c22497a84e2ec8803ba78a7e2e988"></a><br/></td></tr>
<tr class="memitem:ga57025cdb8b8ba51b831a745d93485b46"><td class="memTemplParams" colspan="2">template&lt;class K , int n&gt; </td></tr>
<tr class="memitem:ga57025cdb8b8ba51b831a745d93485b46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00376.html#ga57025cdb8b8ba51b831a745d93485b46">istl_assign_to_fmatrix</a> (FieldMatrix&lt; K, n, n &gt; &amp;fm, const <a class="el" href="a00102.html">DiagonalMatrix</a>&lt; K, n &gt; &amp;s)</td></tr>
<tr class="memitem:ga0f053fd0407ed1cc4bddd149fb6fb8ca"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga0f053fd0407ed1cc4bddd149fb6fb8ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga0f053fd0407ed1cc4bddd149fb6fb8ca">bltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:ga0f053fd0407ed1cc4bddd149fb6fb8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">block lower triangular solve  <a href="a00377.html#ga0f053fd0407ed1cc4bddd149fb6fb8ca"></a><br/></td></tr>
<tr class="memitem:gaf814921e91eff2665f6faf02f5f2077f"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gaf814921e91eff2665f6faf02f5f2077f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gaf814921e91eff2665f6faf02f5f2077f">bltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:gaf814921e91eff2665f6faf02f5f2077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block lower triangular solve  <a href="a00377.html#gaf814921e91eff2665f6faf02f5f2077f"></a><br/></td></tr>
<tr class="memitem:ga44f4aa6e2cf4928911a3f5d1de3044d5"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga44f4aa6e2cf4928911a3f5d1de3044d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga44f4aa6e2cf4928911a3f5d1de3044d5">ubltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:ga44f4aa6e2cf4928911a3f5d1de3044d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block lower triangular solve  <a href="a00377.html#ga44f4aa6e2cf4928911a3f5d1de3044d5"></a><br/></td></tr>
<tr class="memitem:gaccddb305f448a410d5092fc19e65fde7"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gaccddb305f448a410d5092fc19e65fde7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gaccddb305f448a410d5092fc19e65fde7">ubltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:gaccddb305f448a410d5092fc19e65fde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block lower triangular solve  <a href="a00377.html#gaccddb305f448a410d5092fc19e65fde7"></a><br/></td></tr>
<tr class="memitem:gae258e10601de666271f1fc70365acaaf"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gae258e10601de666271f1fc70365acaaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gae258e10601de666271f1fc70365acaaf">butsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:gae258e10601de666271f1fc70365acaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">block upper triangular solve  <a href="a00377.html#gae258e10601de666271f1fc70365acaaf"></a><br/></td></tr>
<tr class="memitem:ga83b10b12a29ea2971cf8176d641b830f"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga83b10b12a29ea2971cf8176d641b830f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga83b10b12a29ea2971cf8176d641b830f">butsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:ga83b10b12a29ea2971cf8176d641b830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block upper triangular solve  <a href="a00377.html#ga83b10b12a29ea2971cf8176d641b830f"></a><br/></td></tr>
<tr class="memitem:gaff15f888a81d558e39b36ac74fea2e42"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gaff15f888a81d558e39b36ac74fea2e42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gaff15f888a81d558e39b36ac74fea2e42">ubutsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:gaff15f888a81d558e39b36ac74fea2e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block upper triangular solve  <a href="a00377.html#gaff15f888a81d558e39b36ac74fea2e42"></a><br/></td></tr>
<tr class="memitem:ga6559fd0a70f600ab376dd2083d8cb0dd"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga6559fd0a70f600ab376dd2083d8cb0dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga6559fd0a70f600ab376dd2083d8cb0dd">ubutsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:ga6559fd0a70f600ab376dd2083d8cb0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block upper triangular solve  <a href="a00377.html#ga6559fd0a70f600ab376dd2083d8cb0dd"></a><br/></td></tr>
<tr class="memitem:gad4c3111bd96d9db74424c3f74765f707"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:gad4c3111bd96d9db74424c3f74765f707"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gad4c3111bd96d9db74424c3f74765f707">bltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:gad4c3111bd96d9db74424c3f74765f707"><td class="mdescLeft">&#160;</td><td class="mdescRight">block lower triangular solve  <a href="a00377.html#gad4c3111bd96d9db74424c3f74765f707"></a><br/></td></tr>
<tr class="memitem:gad1c597c9f5036c4303e0514b2ea72afe"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:gad1c597c9f5036c4303e0514b2ea72afe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gad1c597c9f5036c4303e0514b2ea72afe">bltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:gad1c597c9f5036c4303e0514b2ea72afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block lower triangular solve  <a href="a00377.html#gad1c597c9f5036c4303e0514b2ea72afe"></a><br/></td></tr>
<tr class="memitem:ga5c57521cd2599291ba5117451f87c3c3"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga5c57521cd2599291ba5117451f87c3c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga5c57521cd2599291ba5117451f87c3c3">ubltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga5c57521cd2599291ba5117451f87c3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block lower triangular solve  <a href="a00377.html#ga5c57521cd2599291ba5117451f87c3c3"></a><br/></td></tr>
<tr class="memitem:ga44b020f331bdd453b8540a5721fab10a"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga44b020f331bdd453b8540a5721fab10a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga44b020f331bdd453b8540a5721fab10a">ubltsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga44b020f331bdd453b8540a5721fab10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block lower triangular solve  <a href="a00377.html#ga44b020f331bdd453b8540a5721fab10a"></a><br/></td></tr>
<tr class="memitem:ga1ab5372aabac8f03a77f50227b611fd8"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga1ab5372aabac8f03a77f50227b611fd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga1ab5372aabac8f03a77f50227b611fd8">butsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga1ab5372aabac8f03a77f50227b611fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">block upper triangular solve  <a href="a00377.html#ga1ab5372aabac8f03a77f50227b611fd8"></a><br/></td></tr>
<tr class="memitem:gaaed21180843947bd0efef18d54038998"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:gaaed21180843947bd0efef18d54038998"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gaaed21180843947bd0efef18d54038998">butsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:gaaed21180843947bd0efef18d54038998"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block upper triangular solve  <a href="a00377.html#gaaed21180843947bd0efef18d54038998"></a><br/></td></tr>
<tr class="memitem:ga00c2e6cbce34cf6d04e94567a48bb13c"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga00c2e6cbce34cf6d04e94567a48bb13c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga00c2e6cbce34cf6d04e94567a48bb13c">ubutsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga00c2e6cbce34cf6d04e94567a48bb13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block upper triangular solve  <a href="a00377.html#ga00c2e6cbce34cf6d04e94567a48bb13c"></a><br/></td></tr>
<tr class="memitem:ga89e9f76f178486c9ded34ed26f367bc4"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga89e9f76f178486c9ded34ed26f367bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga89e9f76f178486c9ded34ed26f367bc4">ubutsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga89e9f76f178486c9ded34ed26f367bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block upper triangular solve  <a href="a00377.html#ga89e9f76f178486c9ded34ed26f367bc4"></a><br/></td></tr>
<tr class="memitem:gab20f25b7927dae733827e729fc3c25f7"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gab20f25b7927dae733827e729fc3c25f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gab20f25b7927dae733827e729fc3c25f7">bdsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:gab20f25b7927dae733827e729fc3c25f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, no relaxation  <a href="a00377.html#gab20f25b7927dae733827e729fc3c25f7"></a><br/></td></tr>
<tr class="memitem:gab158b39f3ee085609cbae90a0cf6a5fb"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gab158b39f3ee085609cbae90a0cf6a5fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gab158b39f3ee085609cbae90a0cf6a5fb">bdsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:gab158b39f3ee085609cbae90a0cf6a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, with relaxation  <a href="a00377.html#gab158b39f3ee085609cbae90a0cf6a5fb"></a><br/></td></tr>
<tr class="memitem:ga186a8f655dc2800cefc2911aafeb0bc3"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga186a8f655dc2800cefc2911aafeb0bc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga186a8f655dc2800cefc2911aafeb0bc3">bdsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga186a8f655dc2800cefc2911aafeb0bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, no relaxation  <a href="a00377.html#ga186a8f655dc2800cefc2911aafeb0bc3"></a><br/></td></tr>
<tr class="memitem:ga9bf8b122f68c61211bad5b8265d33c99"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga9bf8b122f68c61211bad5b8265d33c99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga9bf8b122f68c61211bad5b8265d33c99">bdsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga9bf8b122f68c61211bad5b8265d33c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, with relaxation  <a href="a00377.html#ga9bf8b122f68c61211bad5b8265d33c99"></a><br/></td></tr>
<tr class="memitem:ga5bec8914ff3d25fb86ddffef6e38677d"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga5bec8914ff3d25fb86ddffef6e38677d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga5bec8914ff3d25fb86ddffef6e38677d">dbgs</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:ga5bec8914ff3d25fb86ddffef6e38677d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS step.  <a href="a00377.html#ga5bec8914ff3d25fb86ddffef6e38677d"></a><br/></td></tr>
<tr class="memitem:gad0620c6db8bbdf83b696d88132ed94ca"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:gad0620c6db8bbdf83b696d88132ed94ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gad0620c6db8bbdf83b696d88132ed94ca">dbgs</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:gad0620c6db8bbdf83b696d88132ed94ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS step.  <a href="a00377.html#gad0620c6db8bbdf83b696d88132ed94ca"></a><br/></td></tr>
<tr class="memitem:gaf2caef773a37fd65ee1fa76ee0a95c47"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gaf2caef773a37fd65ee1fa76ee0a95c47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gaf2caef773a37fd65ee1fa76ee0a95c47">bsorf</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:gaf2caef773a37fd65ee1fa76ee0a95c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOR step.  <a href="a00377.html#gaf2caef773a37fd65ee1fa76ee0a95c47"></a><br/></td></tr>
<tr class="memitem:ga7a28a998d9fbb3aee2277df66d1971ea"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga7a28a998d9fbb3aee2277df66d1971ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga7a28a998d9fbb3aee2277df66d1971ea">bsorf</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga7a28a998d9fbb3aee2277df66d1971ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOR step.  <a href="a00377.html#ga7a28a998d9fbb3aee2277df66d1971ea"></a><br/></td></tr>
<tr class="memitem:ga3a70747a68e23231ab6cb72b396942ec"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga3a70747a68e23231ab6cb72b396942ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga3a70747a68e23231ab6cb72b396942ec">bsorb</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:ga3a70747a68e23231ab6cb72b396942ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSOR step.  <a href="a00377.html#ga3a70747a68e23231ab6cb72b396942ec"></a><br/></td></tr>
<tr class="memitem:gafe9278b81c72917fb5540162d30ebc3f"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:gafe9278b81c72917fb5540162d30ebc3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gafe9278b81c72917fb5540162d30ebc3f">bsorb</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:gafe9278b81c72917fb5540162d30ebc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSOR step.  <a href="a00377.html#gafe9278b81c72917fb5540162d30ebc3f"></a><br/></td></tr>
<tr class="memitem:ga51ae0ff4aea09b29d3f31ae2f6dfacc5"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga51ae0ff4aea09b29d3f31ae2f6dfacc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga51ae0ff4aea09b29d3f31ae2f6dfacc5">dbjac</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:ga51ae0ff4aea09b29d3f31ae2f6dfacc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi step.  <a href="a00377.html#ga51ae0ff4aea09b29d3f31ae2f6dfacc5"></a><br/></td></tr>
<tr class="memitem:ga30ca0ea04c0b41f024eeb98f0031a70d"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga30ca0ea04c0b41f024eeb98f0031a70d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga30ca0ea04c0b41f024eeb98f0031a70d">dbjac</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a00043.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga30ca0ea04c0b41f024eeb98f0031a70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi step.  <a href="a00377.html#ga30ca0ea04c0b41f024eeb98f0031a70d"></a><br/></td></tr>
<tr class="memitem:gae67699f4a1392779203441b91402a834"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:gae67699f4a1392779203441b91402a834"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gae67699f4a1392779203441b91402a834">bilu0_decomposition</a> (M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>)</td></tr>
<tr class="memdesc:gae67699f4a1392779203441b91402a834"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute ILU decomposition of A. A is overwritten by its decomposition  <a href="a00377.html#gae67699f4a1392779203441b91402a834"></a><br/></td></tr>
<tr class="memitem:ga9a874f8e0ab8b1bd84d6e615f7cde9ee"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga9a874f8e0ab8b1bd84d6e615f7cde9ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga9a874f8e0ab8b1bd84d6e615f7cde9ee">bilu_backsolve</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:ga9a874f8e0ab8b1bd84d6e615f7cde9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU backsolve with stored inverse.  <a href="a00377.html#ga9a874f8e0ab8b1bd84d6e615f7cde9ee"></a><br/></td></tr>
<tr class="memitem:ga65d1f9631fb5e39ebed5b070296d663d"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ga65d1f9631fb5e39ebed5b070296d663d"><td class="memTemplItemLeft" align="right" valign="top">M::field_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga65d1f9631fb5e39ebed5b070296d663d">firstmatrixelement</a> (M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>)</td></tr>
<tr class="memitem:gaba7af467c59c2d25128e17fce742d9ba"><td class="memTemplParams" colspan="2">template&lt;class K , int n, int m&gt; </td></tr>
<tr class="memitem:gaba7af467c59c2d25128e17fce742d9ba"><td class="memTemplItemLeft" align="right" valign="top">K &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gaba7af467c59c2d25128e17fce742d9ba">firstmatrixelement</a> (FieldMatrix&lt; K, n, m &gt; &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>)</td></tr>
<tr class="memitem:ga14d548b134090e0cfb75bf8fd2c1d825"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ga14d548b134090e0cfb75bf8fd2c1d825"><td class="memTemplItemLeft" align="right" valign="top">K &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#ga14d548b134090e0cfb75bf8fd2c1d825">firstmatrixelement</a> (FieldMatrix&lt; K, 1, 1 &gt; &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>)</td></tr>
<tr class="memitem:gab9180edeb5a71c5a5fa867a2b395e562"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:gab9180edeb5a71c5a5fa867a2b395e562"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00377.html#gab9180edeb5a71c5a5fa867a2b395e562">bilu_decomposition</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, int n, M &amp;ILU)</td></tr>
<tr class="memitem:ga1a24fcf9728efd80083fb8d6641a3b0f"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga1a24fcf9728efd80083fb8d6641a3b0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga1a24fcf9728efd80083fb8d6641a3b0f">recursive_printvector</a> (std::ostream &amp;s, const V &amp;v, std::string rowtext, int &amp;counter, int columns, int width, int precision)</td></tr>
<tr class="memitem:ga9c89d56a376d1ef2b35031c9bb64e9dd"><td class="memTemplParams" colspan="2">template&lt;class K , int n&gt; </td></tr>
<tr class="memitem:ga9c89d56a376d1ef2b35031c9bb64e9dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga9c89d56a376d1ef2b35031c9bb64e9dd">recursive_printvector</a> (std::ostream &amp;s, const FieldVector&lt; K, n &gt; &amp;v, std::string rowtext, int &amp;counter, int columns, int width, int precision)</td></tr>
<tr class="memitem:ga8674c142d6b29e12bcb94075f952d1e1"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga8674c142d6b29e12bcb94075f952d1e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga8674c142d6b29e12bcb94075f952d1e1">printvector</a> (std::ostream &amp;s, const V &amp;v, std::string title, std::string rowtext, int columns=1, int width=10, int precision=2)</td></tr>
<tr class="memdesc:ga8674c142d6b29e12bcb94075f952d1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">print an ISTL vector  <a href="a00378.html#ga8674c142d6b29e12bcb94075f952d1e1"></a><br/></td></tr>
<tr class="memitem:gaf09f2e8b784f3eb290a47eab488d9109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00378.html#gaf09f2e8b784f3eb290a47eab488d9109">fill_row</a> (std::ostream &amp;s, int m, int width, int precision)</td></tr>
<tr class="memdesc:gaf09f2e8b784f3eb290a47eab488d9109"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a row of zeros for a non-existing block  <a href="a00378.html#gaf09f2e8b784f3eb290a47eab488d9109"></a><br/></td></tr>
<tr class="memitem:gaa513a0aa7160b4360fc50f5d8fc07e3f"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:gaa513a0aa7160b4360fc50f5d8fc07e3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gaa513a0aa7160b4360fc50f5d8fc07e3f">print_row</a> (std::ostream &amp;s, const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, typename M::size_type I, typename M::size_type J, typename M::size_type therow, int width, int precision)</td></tr>
<tr class="memdesc:gaa513a0aa7160b4360fc50f5d8fc07e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">print one row of a matrix  <a href="a00378.html#gaa513a0aa7160b4360fc50f5d8fc07e3f"></a><br/></td></tr>
<tr class="memitem:ga40fd15efb6b23914860d0bc7ee3a3384"><td class="memTemplParams" colspan="2">template&lt;class K , int n, int m&gt; </td></tr>
<tr class="memitem:ga40fd15efb6b23914860d0bc7ee3a3384"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga40fd15efb6b23914860d0bc7ee3a3384">print_row</a> (std::ostream &amp;s, const FieldMatrix&lt; K, n, m &gt; &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, typename FieldMatrix&lt; K, n, m &gt;::size_type I, typename FieldMatrix&lt; K, n, m &gt;::size_type J, typename FieldMatrix&lt; K, n, m &gt;::size_type therow, int width, int precision)</td></tr>
<tr class="memdesc:ga40fd15efb6b23914860d0bc7ee3a3384"><td class="mdescLeft">&#160;</td><td class="mdescRight">print one row of a matrix, specialization for FieldMatrix  <a href="a00378.html#ga40fd15efb6b23914860d0bc7ee3a3384"></a><br/></td></tr>
<tr class="memitem:gabeea08bf0541b4ebc1c9d445a6e0720b"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:gabeea08bf0541b4ebc1c9d445a6e0720b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gabeea08bf0541b4ebc1c9d445a6e0720b">print_row</a> (std::ostream &amp;s, const FieldMatrix&lt; K, 1, 1 &gt; &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, typename FieldMatrix&lt; K, 1, 1 &gt;::size_type I, typename FieldMatrix&lt; K, 1, 1 &gt;::size_type J, typename FieldMatrix&lt; K, 1, 1 &gt;::size_type therow, int width, int precision)</td></tr>
<tr class="memdesc:gabeea08bf0541b4ebc1c9d445a6e0720b"><td class="mdescLeft">&#160;</td><td class="mdescRight">print one row of a matrix, specialization for FieldMatrix&lt;K,1,1&gt;  <a href="a00378.html#gabeea08bf0541b4ebc1c9d445a6e0720b"></a><br/></td></tr>
<tr class="memitem:ga81eff30b8e58a169e319b49f62e4ea7b"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ga81eff30b8e58a169e319b49f62e4ea7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga81eff30b8e58a169e319b49f62e4ea7b">printmatrix</a> (std::ostream &amp;s, const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, std::string title, std::string rowtext, int width=10, int precision=2)</td></tr>
<tr class="memdesc:ga81eff30b8e58a169e319b49f62e4ea7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a generic block matrix.  <a href="a00378.html#ga81eff30b8e58a169e319b49f62e4ea7b"></a><br/></td></tr>
<tr class="memitem:gaef563e4586001e657d48f01fae628846"><td class="memTemplParams" colspan="2">template&lt;class B , int n, int m, class A &gt; </td></tr>
<tr class="memitem:gaef563e4586001e657d48f01fae628846"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gaef563e4586001e657d48f01fae628846">printSparseMatrix</a> (std::ostream &amp;s, const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; B, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, std::string title, std::string rowtext, int width=3, int precision=2)</td></tr>
<tr class="memdesc:gaef563e4586001e657d48f01fae628846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a <a class="el" href="a00040.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> with fixed sized blocks.  <a href="a00378.html#gaef563e4586001e657d48f01fae628846"></a><br/></td></tr>
<tr class="memitem:gad45515857d1fe0da7c58ae4428ce2faf"><td class="memTemplParams" colspan="2">template&lt;class FieldType , int rows, int cols&gt; </td></tr>
<tr class="memitem:gad45515857d1fe0da7c58ae4428ce2faf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gad45515857d1fe0da7c58ae4428ce2faf">writeMatrixToMatlabHelper</a> (const FieldMatrix&lt; FieldType, rows, cols &gt; &amp;matrix, int rowOffset, int colOffset, std::ostream &amp;s)</td></tr>
<tr class="memdesc:gad45515857d1fe0da7c58ae4428ce2faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for the writeMatrixToMatlab routine.  <a href="a00378.html#gad45515857d1fe0da7c58ae4428ce2faf"></a><br/></td></tr>
<tr class="memitem:gaa3ca16a40229861d07994e606b794638"><td class="memTemplParams" colspan="2">template&lt;class MatrixType &gt; </td></tr>
<tr class="memitem:gaa3ca16a40229861d07994e606b794638"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gaa3ca16a40229861d07994e606b794638">writeMatrixToMatlabHelper</a> (const MatrixType &amp;matrix, int externalRowOffset, int externalColOffset, std::ostream &amp;s)</td></tr>
<tr class="memdesc:gaa3ca16a40229861d07994e606b794638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for the writeMatrixToMatlab routine.  <a href="a00378.html#gaa3ca16a40229861d07994e606b794638"></a><br/></td></tr>
<tr class="memitem:ga19c64bcf9cfcba21151f54c6cee16bba"><td class="memTemplParams" colspan="2">template&lt;class MatrixType &gt; </td></tr>
<tr class="memitem:ga19c64bcf9cfcba21151f54c6cee16bba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga19c64bcf9cfcba21151f54c6cee16bba">writeMatrixToMatlab</a> (const MatrixType &amp;matrix, const std::string &amp;filename, int outputPrecision=18)</td></tr>
<tr class="memdesc:ga19c64bcf9cfcba21151f54c6cee16bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes sparse matrix in a Matlab-readable format.  <a href="a00378.html#ga19c64bcf9cfcba21151f54c6cee16bba"></a><br/></td></tr>
<tr class="memitem:ga41e157954f777b976594afdd2bde700f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00378.html#ga41e157954f777b976594afdd2bde700f">mm_read_header</a> (std::size_t &amp;rows, std::size_t &amp;cols, MMHeader &amp;header, std::istream &amp;istr, bool isVector)</td></tr>
<tr class="memitem:ga8e822f52accbe356f94777ca8f147ce1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , int entries&gt; </td></tr>
<tr class="memitem:ga8e822f52accbe356f94777ca8f147ce1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga8e822f52accbe356f94777ca8f147ce1">mm_read_vector_entries</a> (<a class="el" href="a00046.html">Dune::BlockVector</a>&lt; Dune::FieldVector&lt; T, entries &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;vector, std::size_t size, std::istream &amp;istr)</td></tr>
<tr class="memitem:ga0fb1be3c849932513bd73d7332bfc629"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , int entries&gt; </td></tr>
<tr class="memitem:ga0fb1be3c849932513bd73d7332bfc629"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga0fb1be3c849932513bd73d7332bfc629">readMatrixMarket</a> (<a class="el" href="a00046.html">Dune::BlockVector</a>&lt; Dune::FieldVector&lt; T, entries &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;vector, std::istream &amp;istr)</td></tr>
<tr class="memdesc:ga0fb1be3c849932513bd73d7332bfc629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="a00046.html" title="A vector of blocks with memory management.">BlockVector</a> from a matrix market file.  <a href="a00378.html#ga0fb1be3c849932513bd73d7332bfc629"></a><br/></td></tr>
<tr class="memitem:ga0e714df31aff92a223456a3f9d859970"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , int brows, int bcols&gt; </td></tr>
<tr class="memitem:ga0e714df31aff92a223456a3f9d859970"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga0e714df31aff92a223456a3f9d859970">readMatrixMarket</a> (<a class="el" href="a00040.html">Dune::BCRSMatrix</a>&lt; Dune::FieldMatrix&lt; T, brows, bcols &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;matrix, std::istream &amp;istr)</td></tr>
<tr class="memdesc:ga0e714df31aff92a223456a3f9d859970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a sparse matrix from a matrix market file.  <a href="a00378.html#ga0e714df31aff92a223456a3f9d859970"></a><br/></td></tr>
<tr class="memitem:ga9ff37bc25665103489866e12aa88d1db"><td class="memTemplParams" colspan="2">template&lt;typename B , int i, int j&gt; </td></tr>
<tr class="memitem:ga9ff37bc25665103489866e12aa88d1db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga9ff37bc25665103489866e12aa88d1db">mm_print_entry</a> (const FieldMatrix&lt; B, i, j &gt; &amp;entry, typename FieldMatrix&lt; B, i, j &gt;::size_type rowidx, typename FieldMatrix&lt; B, i, j &gt;::size_type colidx, std::ostream &amp;ostr)</td></tr>
<tr class="memitem:gad55f1fe4cb16c5e7822f12e454166469"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:gad55f1fe4cb16c5e7822f12e454166469"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gad55f1fe4cb16c5e7822f12e454166469">mm_print_vector_entry</a> (const V &amp;entry, std::ostream &amp;ostr, const integral_constant&lt; int, 1 &gt; &amp;)</td></tr>
<tr class="memitem:ga0e0cbc61ab4f5b8b8749e03b8272bbc3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga0e0cbc61ab4f5b8b8749e03b8272bbc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga0e0cbc61ab4f5b8b8749e03b8272bbc3">mm_print_vector_entry</a> (const V &amp;vector, std::ostream &amp;ostr, const integral_constant&lt; int, 0 &gt; &amp;)</td></tr>
<tr class="memitem:ga4ffd3c490badd2df43eb4a6d0e0119c4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , int i&gt; </td></tr>
<tr class="memitem:ga4ffd3c490badd2df43eb4a6d0e0119c4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga4ffd3c490badd2df43eb4a6d0e0119c4">countEntries</a> (const <a class="el" href="a00046.html">BlockVector</a>&lt; FieldVector&lt; T, i &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;vector)</td></tr>
<tr class="memitem:ga2d50646c7976d36d79efe43b917e10c8"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga2d50646c7976d36d79efe43b917e10c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga2d50646c7976d36d79efe43b917e10c8">writeMatrixMarket</a> (const V &amp;vector, std::ostream &amp;ostr, const integral_constant&lt; int, 0 &gt; &amp;)</td></tr>
<tr class="memitem:ga936f52ba15362e001782f2e36865123c"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga936f52ba15362e001782f2e36865123c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga936f52ba15362e001782f2e36865123c">writeMatrixMarket</a> (const M &amp;matrix, std::ostream &amp;ostr, const integral_constant&lt; int, 1 &gt; &amp;)</td></tr>
<tr class="memitem:ga8da01d126c9f37e57fa4f719e1d05487"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga8da01d126c9f37e57fa4f719e1d05487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga8da01d126c9f37e57fa4f719e1d05487">writeMatrixMarket</a> (const M &amp;matrix, std::ostream &amp;ostr)</td></tr>
<tr class="memdesc:ga8da01d126c9f37e57fa4f719e1d05487"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes a ISTL matrix or vector to a stream in matrix market format.  <a href="a00378.html#ga8da01d126c9f37e57fa4f719e1d05487"></a><br/></td></tr>
<tr class="memitem:gaa3ec6c219013ec108e0a63aa4b7a654e"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gaa3ec6c219013ec108e0a63aa4b7a654e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gaa3ec6c219013ec108e0a63aa4b7a654e">storeMatrixMarket</a> (const M &amp;matrix, std::string filename)</td></tr>
<tr class="memdesc:gaa3ec6c219013ec108e0a63aa4b7a654e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a parallel matrix/vector in matrix market format in a file.  <a href="a00378.html#gaa3ec6c219013ec108e0a63aa4b7a654e"></a><br/></td></tr>
<tr class="memitem:ga5c975b6d667422e0b0dd63ae62d2be22"><td class="memTemplParams" colspan="2">template&lt;typename M , typename G , typename L &gt; </td></tr>
<tr class="memitem:ga5c975b6d667422e0b0dd63ae62d2be22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga5c975b6d667422e0b0dd63ae62d2be22">storeMatrixMarket</a> (const M &amp;matrix, std::string filename, const <a class="el" href="a00199.html">OwnerOverlapCopyCommunication</a>&lt; G, L &gt; &amp;comm, bool storeIndices=true)</td></tr>
<tr class="memdesc:ga5c975b6d667422e0b0dd63ae62d2be22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a parallel matrix/vector in matrix market format in a file.  <a href="a00378.html#ga5c975b6d667422e0b0dd63ae62d2be22"></a><br/></td></tr>
<tr class="memitem:ga1bc5b5677a5be24d72a7d95214fd0d30"><td class="memTemplParams" colspan="2">template&lt;typename M , typename G , typename L &gt; </td></tr>
<tr class="memitem:ga1bc5b5677a5be24d72a7d95214fd0d30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#ga1bc5b5677a5be24d72a7d95214fd0d30">loadMatrixMarket</a> (M &amp;matrix, const std::string &amp;filename, <a class="el" href="a00199.html">OwnerOverlapCopyCommunication</a>&lt; G, L &gt; &amp;comm, bool readIndices=true)</td></tr>
<tr class="memdesc:ga1bc5b5677a5be24d72a7d95214fd0d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a parallel matrix/vector stored in matrix market format.  <a href="a00378.html#ga1bc5b5677a5be24d72a7d95214fd0d30"></a><br/></td></tr>
<tr class="memitem:gac23bb6abb2a5b397781ea75c0ba134d8"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gac23bb6abb2a5b397781ea75c0ba134d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00378.html#gac23bb6abb2a5b397781ea75c0ba134d8">loadMatrixMarket</a> (M &amp;matrix, const std::string &amp;filename)</td></tr>
<tr class="memdesc:gac23bb6abb2a5b397781ea75c0ba134d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a matrix/vector stored in matrix market format.  <a href="a00378.html#gac23bb6abb2a5b397781ea75c0ba134d8"></a><br/></td></tr>
<tr class="memitem:gaa6b345f332f41378c4a51cb8069f2afa"><td class="memTemplParams" colspan="2">template&lt;class T , class A , class A1 , class A2 , int n, int m, int k&gt; </td></tr>
<tr class="memitem:gaa6b345f332f41378c4a51cb8069f2afa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00369.html#gaa6b345f332f41378c4a51cb8069f2afa">matMultTransposeMat</a> (<a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, n, k &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;res, const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, n, m &gt;, A1 &gt; &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, k, m &gt;, A2 &gt; &amp;matt, bool tryHard=false)</td></tr>
<tr class="memdesc:gaa6b345f332f41378c4a51cb8069f2afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate product of a sparse matrix with a transposed sparse matrices ( <img class="formulaInl" alt="$C=A*B^T$" src="form_21.png"/>).  <a href="a00369.html#gaa6b345f332f41378c4a51cb8069f2afa"></a><br/></td></tr>
<tr class="memitem:ga1829a6141ae2cae5a1ecab7e0207123d"><td class="memTemplParams" colspan="2">template&lt;class T , class A , class A1 , class A2 , int n, int m, int k&gt; </td></tr>
<tr class="memitem:ga1829a6141ae2cae5a1ecab7e0207123d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00369.html#ga1829a6141ae2cae5a1ecab7e0207123d">matMultMat</a> (<a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;res, const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, n, k &gt;, A1 &gt; &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, k, m &gt;, A2 &gt; &amp;matt, bool tryHard=false)</td></tr>
<tr class="memdesc:ga1829a6141ae2cae5a1ecab7e0207123d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate product of two sparse matrices ( <img class="formulaInl" alt="$C=A*B$" src="form_20.png"/>).  <a href="a00369.html#ga1829a6141ae2cae5a1ecab7e0207123d"></a><br/></td></tr>
<tr class="memitem:ga14bd816d4157debb97ae87a157fd3af2"><td class="memTemplParams" colspan="2">template&lt;class T , class A , class A1 , class A2 , int n, int m, int k&gt; </td></tr>
<tr class="memitem:ga14bd816d4157debb97ae87a157fd3af2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00369.html#ga14bd816d4157debb97ae87a157fd3af2">transposeMatMultMat</a> (<a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;res, const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, k, n &gt;, A1 &gt; &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, k, m &gt;, A2 &gt; &amp;matt, bool tryHard=false)</td></tr>
<tr class="memdesc:ga14bd816d4157debb97ae87a157fd3af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate product of a transposed sparse matrix with another sparse matrices ( <img class="formulaInl" alt="$C=A^T*B$" src="form_22.png"/>).  <a href="a00369.html#ga14bd816d4157debb97ae87a157fd3af2"></a><br/></td></tr>
<tr class="memitem:a63e2af44500c49cc412112bcc645c7bd"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:a63e2af44500c49cc412112bcc645c7bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a63e2af44500c49cc412112bcc645c7bd">redistributeSparsityPattern</a> (M &amp;origMatrix, M &amp;newMatrix, C &amp;origComm, C &amp;newComm, <a class="el" href="a00219.html">RedistributeInformation</a>&lt; C &gt; &amp;ri)</td></tr>
<tr class="memitem:a3f63ab17e9c1235103a0512bda341ca2"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:a3f63ab17e9c1235103a0512bda341ca2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a3f63ab17e9c1235103a0512bda341ca2">redistributeMatrixEntries</a> (M &amp;origMatrix, M &amp;newMatrix, C &amp;origComm, C &amp;newComm, <a class="el" href="a00219.html">RedistributeInformation</a>&lt; C &gt; &amp;ri)</td></tr>
<tr class="memitem:ab59fe4d0a58ea0575b42993d7563d34b"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:ab59fe4d0a58ea0575b42993d7563d34b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#ab59fe4d0a58ea0575b42993d7563d34b">redistributeMatrix</a> (M &amp;origMatrix, M &amp;newMatrix, C &amp;origComm, C &amp;newComm, <a class="el" href="a00219.html">RedistributeInformation</a>&lt; C &gt; &amp;ri)</td></tr>
<tr class="memdesc:ab59fe4d0a58ea0575b42993d7563d34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribute a matrix according to given domain decompositions.  <a href="#ab59fe4d0a58ea0575b42993d7563d34b"></a><br/></td></tr>
<tr class="memitem:gaaff8ca954251eb8047a3416def80c4bc"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:gaaff8ca954251eb8047a3416def80c4bc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00369.html#gaaff8ca954251eb8047a3416def80c4bc">countNonZeros</a> (const M &amp;matrix)</td></tr>
<tr class="memdesc:gaaff8ca954251eb8047a3416def80c4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nonzero fields in the matrix.  <a href="a00369.html#gaaff8ca954251eb8047a3416def80c4bc"></a><br/></td></tr>
<tr class="memitem:a131e13bda7cee7fa0c8e4a96e8d46801"><td class="memTemplParams" colspan="2">template&lt;class M , class C &gt; </td></tr>
<tr class="memitem:a131e13bda7cee7fa0c8e4a96e8d46801"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a131e13bda7cee7fa0c8e4a96e8d46801">printGlobalSparseMatrix</a> (const M &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, C &amp;ooc, std::ostream &amp;os)</td></tr>
<tr class="memitem:a4b873012cc8b0bc715d9882d4a130238"><td class="memTemplParams" colspan="2">template&lt;typename G , typename EP , typename VM , typename EM &gt; </td></tr>
<tr class="memitem:a4b873012cc8b0bc715d9882d4a130238"><td class="memTemplItemLeft" align="right" valign="top">PropertyMapTypeSelector<br class="typebreak"/>
&lt; <a class="el" href="a00295.html">Amg::VertexVisitedTag</a>, <br class="typebreak"/>
<a class="el" href="a00205.html">Amg::PropertiesGraph</a>&lt; G, <br class="typebreak"/>
<a class="el" href="a00293.html">Amg::VertexProperties</a>, EP, VM, <br class="typebreak"/>
EM &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a4b873012cc8b0bc715d9882d4a130238">get</a> (const <a class="el" href="a00295.html">Amg::VertexVisitedTag</a> &amp;tag, <a class="el" href="a00205.html">Amg::PropertiesGraph</a>&lt; G, <a class="el" href="a00293.html">Amg::VertexProperties</a>, EP, VM, EM &gt; &amp;graph)</td></tr>
<tr class="memitem:a62bc57d5768b1bc98357bac259795327"><td class="memTemplParams" colspan="2">template&lt;class G , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a62bc57d5768b1bc98357bac259795327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a62bc57d5768b1bc98357bac259795327">fillIndexSetHoles</a> (const G &amp;graph, <a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm)</td></tr>
<tr class="memdesc:a62bc57d5768b1bc98357bac259795327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the holes in an index set.  <a href="#a62bc57d5768b1bc98357bac259795327"></a><br/></td></tr>
<tr class="memitem:a8c2d3ad3ad2e9a5471bdd5e2538d99ab"><td class="memTemplParams" colspan="2">template&lt;class G , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a8c2d3ad3ad2e9a5471bdd5e2538d99ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a8c2d3ad3ad2e9a5471bdd5e2538d99ab">buildCommunication</a> (const G &amp;graph, std::vector&lt; int &gt; &amp;realparts, <a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm, <a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; *&amp;outcomm, <a class="el" href="a00221.html">RedistributeInterface</a> &amp;redistInf, bool verbose=false)</td></tr>
<tr class="memitem:a8fd07ea3f22cb47275859d39d7bdffef"><td class="memTemplParams" colspan="2">template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:a8fd07ea3f22cb47275859d39d7bdffef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a8fd07ea3f22cb47275859d39d7bdffef">print_carray</a> (S &amp;os, T *array, std::size_t l)</td></tr>
<tr class="memitem:a12142a94f57e63fc150fbd85e9eeace8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a12142a94f57e63fc150fbd85e9eeace8">isValidGraph</a> (std::size_t noVtx, std::size_t gnoVtx, <a class="el" href="a00360.html#a1a7c58447d9b6097a20628d16c30a0e0">idxtype</a> noEdges, <a class="el" href="a00360.html#a1a7c58447d9b6097a20628d16c30a0e0">idxtype</a> *xadj, <a class="el" href="a00360.html#a1a7c58447d9b6097a20628d16c30a0e0">idxtype</a> *adjncy, bool checkSymmetry)</td></tr>
<tr class="memitem:ab921ddf0c15ca681e57e22516580f92b"><td class="memTemplParams" colspan="2">template&lt;class M , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ab921ddf0c15ca681e57e22516580f92b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#ab921ddf0c15ca681e57e22516580f92b">commGraphRepartition</a> (const M &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, <a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm, int nparts, <a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; *&amp;outcomm, <a class="el" href="a00221.html">RedistributeInterface</a> &amp;redistInf, bool verbose=false)</td></tr>
<tr class="memitem:ae0957927171371b1f8293a936b1c03f2"><td class="memTemplParams" colspan="2">template&lt;class G , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ae0957927171371b1f8293a936b1c03f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#ae0957927171371b1f8293a936b1c03f2">graphRepartition</a> (const G &amp;graph, <a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm, int nparts, <a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; *&amp;outcomm, <a class="el" href="a00221.html">RedistributeInterface</a> &amp;redistInf, bool verbose=false)</td></tr>
<tr class="memdesc:ae0957927171371b1f8293a936b1c03f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute a graph repartition for a giving graph and indexset.  <a href="#ae0957927171371b1f8293a936b1c03f2"></a><br/></td></tr>
<tr class="memitem:a77e09764b4604335599cfe3fd8abc2c1"><td class="memTemplParams" colspan="2">template&lt;class M , class K , int n&gt; </td></tr>
<tr class="memitem:a77e09764b4604335599cfe3fd8abc2c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a77e09764b4604335599cfe3fd8abc2c1">istl_assign_to_fmatrix</a> (DenseMatrix&lt; M &gt; &amp;fm, const <a class="el" href="a00230.html">ScaledIdentityMatrix</a>&lt; K, n &gt; &amp;s)</td></tr>
<tr class="memitem:a9d048590e7b7c54f056d4fce14390921"><td class="memTemplParams" colspan="2">template&lt;class T , class A , int n, int m&gt; </td></tr>
<tr class="memitem:a9d048590e7b7c54f056d4fce14390921"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a9d048590e7b7c54f056d4fce14390921">writeCompColMatrixToMatlab</a> (const <a class="el" href="a00269.html">SuperLUMatrix</a>&lt; <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, std::ostream &amp;os)</td></tr>
<tr class="memitem:a8504f1a06af26dfaf590e38c5110a368"><td class="memTemplParams" colspan="2">template&lt;class F , class MRS &gt; </td></tr>
<tr class="memitem:a8504f1a06af26dfaf590e38c5110a368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a8504f1a06af26dfaf590e38c5110a368">copyToSuperMatrix</a> (F &amp;initializer, const MRS &amp;mrs)</td></tr>
<tr class="memitem:ae4d4d39f175cd1fe12105f4b7d2ca2ee"><td class="memTemplParams" colspan="2">template&lt;class F , class M , class S &gt; </td></tr>
<tr class="memitem:ae4d4d39f175cd1fe12105f4b7d2ca2ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#ae4d4d39f175cd1fe12105f4b7d2ca2ee">copyToSuperMatrix</a> (F &amp;initializer, const <a class="el" href="a00173.html">MatrixRowSubset</a>&lt; M, S &gt; &amp;mrs)</td></tr>
<tr class="memitem:a703e176b3b09ff5663605fe5408e86c3"><td class="memTemplParams" colspan="2">template&lt;class B , class TA , int n, int m&gt; </td></tr>
<tr class="memitem:a703e176b3b09ff5663605fe5408e86c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a703e176b3b09ff5663605fe5408e86c3">operator==</a> (<a class="el" href="a00269.html">SuperLUMatrix</a>&lt; <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; B, n, m &gt;, TA &gt; &gt; &amp;sla, <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; B, n, m &gt;, TA &gt; &amp;a)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a1a7c58447d9b6097a20628d16c30a0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="a00360.html#a1a7c58447d9b6097a20628d16c30a0e0">Dune::idxtype</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8c2d3ad3ad2e9a5471bdd5e2538d99ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::buildCommunication </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>realparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; *&amp;&#160;</td>
          <td class="paramname"><em>outcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedistributeInterface &amp;&#160;</td>
          <td class="paramname"><em>redistInf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00221.html#acb8bc39209734b476152cb4b3702e4bb">Dune::RedistributeInterface::addReceiveIndex()</a>, <a class="el" href="a00221.html#a9509d4dd7630b3594daba9096ac0393e">Dune::RedistributeInterface::buildSendInterface()</a>, <a class="el" href="a00199.html#a5b32b95b70fa9b268c10936b98d7aef3">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::communicator()</a>, <a class="el" href="a00199.html#a4e687a57fbe63f894d3b7a24d5ad737a">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::getSolverCategory()</a>, <a class="el" href="a00199.html#a05e830ea89a7da371e59c5d574d3b851">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::globalLookup()</a>, <a class="el" href="a00328.html#ac28efa16fb8062e271f8b7a373cc1734">index</a>, <a class="el" href="a00199.html#ad0879971da9f61ed37b1717e8c24222d">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::indexSet()</a>, and <a class="el" href="a00221.html#a8fed3306842bd899bc27f52a0254a818">Dune::RedistributeInterface::setCommunicator()</a>.</p>

<p>Referenced by <a class="el" href="a00360.html#ab921ddf0c15ca681e57e22516580f92b">commGraphRepartition()</a>, and <a class="el" href="a00360.html#ae0957927171371b1f8293a936b1c03f2">graphRepartition()</a>.</p>

</div>
</div>
<a class="anchor" id="ab921ddf0c15ca681e57e22516580f92b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::commGraphRepartition </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; *&amp;&#160;</td>
          <td class="paramname"><em>outcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedistributeInterface &amp;&#160;</td>
          <td class="paramname"><em>redistInf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00360.html#a8c2d3ad3ad2e9a5471bdd5e2538d99ab">buildCommunication()</a>, <a class="el" href="a00199.html#a91915027cb24a712dad72a2529afad7c">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::buildGlobalLookup()</a>, <a class="el" href="a00199.html#a5b32b95b70fa9b268c10936b98d7aef3">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::communicator()</a>, <a class="el" href="a00199.html#a4c653d803773152aaa28fb2c217a02e4">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::copyOwnerToAll()</a>, <a class="el" href="a00360.html#a62bc57d5768b1bc98357bac259795327">fillIndexSetHoles()</a>, <a class="el" href="a00360.html#a12142a94f57e63fc150fbd85e9eeace8">isValidGraph()</a>, <a class="el" href="a00360.html#a8fd07ea3f22cb47275859d39d7bdffef">print_carray()</a>, and <a class="el" href="a00199.html#a3493d50c48eca40162df19e85154d540">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::remoteIndices()</a>.</p>

<p>Referenced by <a class="el" href="a00372.html#ga928018044a608d5e9528f06ff7b35ca6">Dune::Amg::repartitionAndDistributeMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a8504f1a06af26dfaf590e38c5110a368"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class MRS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::copyToSuperMatrix </td>
          <td>(</td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>initializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MRS &amp;&#160;</td>
          <td class="paramname"><em>mrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>, and <a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>.</p>

<p>Referenced by <a class="el" href="a00373.html#gadaa03d2a62f0be753c5e0c7091e1e6f0">Dune::SeqOverlappingSchwarzAssembler&lt; SuperLU&lt; T &gt; &gt;::assembleLocalProblems()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4d4d39f175cd1fe12105f4b7d2ca2ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class M , class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::copyToSuperMatrix </td>
          <td>(</td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>initializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixRowSubset&lt; M, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>mrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00173.html#ad76a17d9ed9a56411ba1f9f8ecfb280f">Dune::MatrixRowSubset&lt; M, S &gt;::begin()</a>, <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>, <a class="el" href="a00173.html#a5f1414e2ea54937a857c2242e2eff833">Dune::MatrixRowSubset&lt; M, S &gt;::end()</a>, <a class="el" href="a00328.html#ac28efa16fb8062e271f8b7a373cc1734">index</a>, <a class="el" href="a00173.html#a3e9f461dcf3673fe708567ca0b9d22c1">Dune::MatrixRowSubset&lt; M, S &gt;::matrix()</a>, <a class="el" href="a00156.html#ae2d1358bee5ae1954b7b573fa0e6a260">Dune::Matrix&lt; T, A &gt;::N()</a>, <a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>, and <a class="el" href="a00173.html#a7656afff5c15c68ba74848726d0de270">Dune::MatrixRowSubset&lt; M, S &gt;::rowIndexSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a62bc57d5768b1bc98357bac259795327"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::fillIndexSetHoles </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the holes in an index set. </p>
<p>In general the index set only needs to know those indices where communication my occur. In usual FE computations these are just those near the processor boundaries.</p>
<p>For the repartitioning we need to know all all indices for which data is stored. The missing indices will be created in this method.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to reparition. </td></tr>
    <tr><td class="paramname">oocomm</td><td>The communication information. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00199.html#a91915027cb24a712dad72a2529afad7c">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::buildGlobalLookup()</a>, <a class="el" href="a00199.html#a5b32b95b70fa9b268c10936b98d7aef3">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::communicator()</a>, <a class="el" href="a00199.html#ae652199bd10eeea6f5bcd678893fe245">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::freeGlobalLookup()</a>, <a class="el" href="a00199.html#a05e830ea89a7da371e59c5d574d3b851">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::globalLookup()</a>, <a class="el" href="a00199.html#ad0879971da9f61ed37b1717e8c24222d">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::indexSet()</a>, <a class="el" href="a00198.html#a7d966939fcbeee9a336da65f647a47b2a03901dd537cba1347bc75afeb5935f1a">Dune::OwnerOverlapCopyAttributeSet::owner</a>, and <a class="el" href="a00199.html#a3493d50c48eca40162df19e85154d540">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::remoteIndices()</a>.</p>

<p>Referenced by <a class="el" href="a00360.html#ab921ddf0c15ca681e57e22516580f92b">commGraphRepartition()</a>, and <a class="el" href="a00360.html#ae0957927171371b1f8293a936b1c03f2">graphRepartition()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b873012cc8b0bc715d9882d4a130238"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename EP , typename VM , typename EM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertyMapTypeSelector&lt;<a class="el" href="a00295.html">Amg::VertexVisitedTag</a>,<a class="el" href="a00205.html">Amg::PropertiesGraph</a>&lt;G,<a class="el" href="a00293.html">Amg::VertexProperties</a>,EP,VM,EM&gt; &gt;::Type Dune::get </td>
          <td>(</td>
          <td class="paramtype">const Amg::VertexVisitedTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Amg::PropertiesGraph&lt; G, Amg::VertexProperties, EP, VM, EM &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00372.html#gga5825cec10a2c25a49ac7d7ae91321edaa3b91960c297fce34a3c69bee71c55bec">Dune::Amg::VertexProperties::VISITED</a>.</p>

</div>
</div>
<a class="anchor" id="ae0957927171371b1f8293a936b1c03f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::graphRepartition </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00199.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; *&amp;&#160;</td>
          <td class="paramname"><em>outcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedistributeInterface &amp;&#160;</td>
          <td class="paramname"><em>redistInf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>execute a graph repartition for a giving graph and indexset. </p>
<p>This function provides repartition functionality using the PARMETIS library</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graph</td><td>The given graph to repartition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">oocomm</td><td>The parallel information about the graph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nparts</td><td>The number of domains the repartitioning should achieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outcomm</td><td>Pointer store the parallel information of the redistributed domains in. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">redistInf</td><td>Redistribute interface </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">verbose</td><td>Verbosity flag to give out additional information. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00360.html#a8c2d3ad3ad2e9a5471bdd5e2538d99ab">buildCommunication()</a>, <a class="el" href="a00199.html#a91915027cb24a712dad72a2529afad7c">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::buildGlobalLookup()</a>, <a class="el" href="a00199.html#a5b32b95b70fa9b268c10936b98d7aef3">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::communicator()</a>, <a class="el" href="a00199.html#af90cb0791ad1e695a541f196a00f8b53">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::copyCopyToAll()</a>, <a class="el" href="a00199.html#a4c653d803773152aaa28fb2c217a02e4">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::copyOwnerToAll()</a>, <a class="el" href="a00360.html#a62bc57d5768b1bc98357bac259795327">fillIndexSetHoles()</a>, <a class="el" href="a00199.html#a4e687a57fbe63f894d3b7a24d5ad737a">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::getSolverCategory()</a>, <a class="el" href="a00199.html#a05e830ea89a7da371e59c5d574d3b851">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::globalLookup()</a>, <a class="el" href="a00328.html#ac28efa16fb8062e271f8b7a373cc1734">index</a>, and <a class="el" href="a00199.html#ad0879971da9f61ed37b1717e8c24222d">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::indexSet()</a>.</p>

<p>Referenced by <a class="el" href="a00372.html#ga928018044a608d5e9528f06ff7b35ca6">Dune::Amg::repartitionAndDistributeMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a77e09764b4604335599cfe3fd8abc2c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class K , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::istl_assign_to_fmatrix </td>
          <td>(</td>
          <td class="paramtype">DenseMatrix&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>fm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScaledIdentityMatrix&lt; K, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00230.html#a5163675133de4de5a305a6bfa506c71a">Dune::ScaledIdentityMatrix&lt; K, n &gt;::scalar()</a>.</p>

</div>
</div>
<a class="anchor" id="a12142a94f57e63fc150fbd85e9eeace8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::isValidGraph </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>noVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>gnoVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idxtype&#160;</td>
          <td class="paramname"><em>noEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idxtype *&#160;</td>
          <td class="paramname"><em>xadj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idxtype *&#160;</td>
          <td class="paramname"><em>adjncy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkSymmetry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00360.html#ab921ddf0c15ca681e57e22516580f92b">commGraphRepartition()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d6c22497a84e2ec8803ba78a7e2e988"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Dune::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVector&lt; K, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send <a class="el" href="a00046.html" title="A vector of blocks with memory management.">BlockVector</a> to an output stream. </p>

</div>
</div>
<a class="anchor" id="a703e176b3b09ff5663605fe5408e86c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class TA , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator== </td>
          <td>(</td>
          <td class="paramtype">SuperLUMatrix&lt; BCRSMatrix&lt; FieldMatrix&lt; B, n, m &gt;, TA &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sla</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BCRSMatrix&lt; FieldMatrix&lt; B, n, m &gt;, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8fd07ea3f22cb47275859d39d7bdffef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::print_carray </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00360.html#ab921ddf0c15ca681e57e22516580f92b">commGraphRepartition()</a>.</p>

</div>
</div>
<a class="anchor" id="a131e13bda7cee7fa0c8e4a96e8d46801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::printGlobalSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>ooc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00372.html#ga928018044a608d5e9528f06ff7b35ca6">Dune::Amg::repartitionAndDistributeMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ab59fe4d0a58ea0575b42993d7563d34b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeMatrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedistributeInformation&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redistribute a matrix according to given domain decompositions. </p>
<p>All the parameters for this function can be obtained by calling graphRepartition with the graph of the original matrix.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">origMatrix</td><td>The matrix on the original partitioning. </td></tr>
    <tr><td class="paramname">newMatrix</td><td>An empty matrix to store the new redistributed matrix in. </td></tr>
    <tr><td class="paramname">origComm</td><td>The parallel information of the original partitioning. </td></tr>
    <tr><td class="paramname">newComm</td><td>The parallel information of the new partitioning. </td></tr>
    <tr><td class="paramname">ri</td><td>The remote index information between the original and the new partitioning. Upon exit of this method it will be prepared for copying from owner to owner vertices for data redistribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The matrix type. It is assumed to be sparse. E.g. <a class="el" href="a00040.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a>. </td></tr>
    <tr><td class="paramname">C</td><td>The type of the parallel information, see <a class="el" href="a00199.html" title="A class setting up standard communication for a two-valued attribute set with owner/overlap/copy sema...">OwnerOverlapCopyCommunication</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00360.html#a3f63ab17e9c1235103a0512bda341ca2">redistributeMatrixEntries()</a>, <a class="el" href="a00360.html#a63e2af44500c49cc412112bcc645c7bd">redistributeSparsityPattern()</a>, <a class="el" href="a00219.html#a261858ec5df802d0edb0cd695a7e1541">Dune::RedistributeInformation&lt; T &gt;::setNoBackwardsCopyRows()</a>, <a class="el" href="a00219.html#aacf0291f4930f53aae6169cb2d923b3a">Dune::RedistributeInformation&lt; T &gt;::setNoCopyRows()</a>, and <a class="el" href="a00219.html#ac60320c6a5a30da6b7d91978630e6fad">Dune::RedistributeInformation&lt; T &gt;::setNoRows()</a>.</p>

<p>Referenced by <a class="el" href="a00372.html#ga928018044a608d5e9528f06ff7b35ca6">Dune::Amg::repartitionAndDistributeMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f63ab17e9c1235103a0512bda341ca2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeMatrixEntries </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedistributeInformation&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00219.html#ae899755bccc5dcceedd6cec819f735a0">Dune::RedistributeInformation&lt; T &gt;::getBackwardsCopyRowSize()</a>, <a class="el" href="a00219.html#acac3ce3d747679f05a849cb00670970f">Dune::RedistributeInformation&lt; T &gt;::getCopyRowSize()</a>, <a class="el" href="a00219.html#a56c7450287d847566f938b12cd646c8d">Dune::RedistributeInformation&lt; T &gt;::getRowSize()</a>, <a class="el" href="a00262.html#ae061380ac961490be6ee353cf0dc1733af68b4bea0af23042d9597ca634782187">Dune::SolverCategory::nonoverlapping</a>, and <a class="el" href="a00378.html#ga81eff30b8e58a169e319b49f62e4ea7b">printmatrix()</a>.</p>

<p>Referenced by <a class="el" href="a00372.html#ga98f19e8c83876884bcc81b0b62e84124">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::recalculateGalerkin()</a>, and <a class="el" href="a00360.html#ab59fe4d0a58ea0575b42993d7563d34b">redistributeMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a63e2af44500c49cc412112bcc645c7bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RedistributeInformation&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>, <a class="el" href="a00219.html#ae899755bccc5dcceedd6cec819f735a0">Dune::RedistributeInformation&lt; T &gt;::getBackwardsCopyRowSize()</a>, <a class="el" href="a00219.html#acac3ce3d747679f05a849cb00670970f">Dune::RedistributeInformation&lt; T &gt;::getCopyRowSize()</a>, <a class="el" href="a00219.html#a56c7450287d847566f938b12cd646c8d">Dune::RedistributeInformation&lt; T &gt;::getRowSize()</a>, <a class="el" href="a00262.html#ae061380ac961490be6ee353cf0dc1733af68b4bea0af23042d9597ca634782187">Dune::SolverCategory::nonoverlapping</a>, <a class="el" href="a00219.html#a9c439208efce88c9c852ecbed1ed53b5">Dune::RedistributeInformation&lt; T &gt;::redistributeBackward()</a>, and <a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>.</p>

<p>Referenced by <a class="el" href="a00360.html#ab59fe4d0a58ea0575b42993d7563d34b">redistributeMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d048590e7b7c54f056d4fce14390921"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::writeCompColMatrixToMatlab </td>
          <td>(</td>
          <td class="paramtype">const SuperLUMatrix&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>, <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, and <a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 4 2012 12:02:18 for dune-istl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
