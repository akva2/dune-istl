<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>dune-istl: Dune::Amg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00360.html">Dune</a></li><li class="navelem"><a class="el" href="a00366.html">Amg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dune::Amg Namespace Reference<div class="ingroups"><a class="el" href="a00374.html">Scalar products</a> &#124; <a class="el" href="a00373.html">Preconditioners</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">AggregationCriterion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all aggregation criterions.  <a href="a00017.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">Dependency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00099.html" title="Dependency policy for symmetric matrices.">Dependency</a> policy for symmetric matrices.  <a href="a00099.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html">SymmetricDependency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00099.html" title="Dependency policy for symmetric matrices.">Dependency</a> policy for symmetric matrices.  <a href="a00281.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">Diagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Norm that uses only the [N][N] entry of the block to determine couplings.  <a href="a00101.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">FirstDiagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Norm that uses only the [0][0] entry of the block to determine couplings.  <a href="a00115.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html">RowSum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor using the row sum (infinity) norm to determine strong couplings.  <a href="a00224.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">FrobeniusNorm</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">AlwaysOneNorm</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00280.html">SymmetricCriterion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Criterion taking advantage of symmetric matrices.  <a href="a00280.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00287.html">UnSymmetricCriterion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Criterion suited for unsymmetric matrices.  <a href="a00287.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">AggregatesMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing information about the mapping of the vertices onto aggregates.  <a href="a00013.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">Aggregate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for temporarily storing the vertices of an aggregate in.  <a href="a00010.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">Aggregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for building the aggregates.  <a href="a00019.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">AMG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel algebraic multigrid based on agglomeration.  <a href="a00031.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">ApplyHelper</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">ApplyHelper&lt; 0 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">CombinedFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">ConstructionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for generically constructing non default constructable types.  <a href="a00076.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">ConstructionTraits&lt; BlockVector&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">OverlappingSchwarzOperatorArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">NonoverlappingOperatorArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00200.html">OwnerOverlapCopyCommunicationArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00251.html">SequentialCommunicationArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">ConstructionTraits&lt; OverlappingSchwarzOperator&lt; M, X, Y, C &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">ConstructionTraits&lt; NonoverlappingSchwarzOperator&lt; M, X, Y, C &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">MatrixAdapterArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">ConstructionTraits&lt; MatrixAdapter&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">ConstructionTraits&lt; SequentialInformation &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">ConstructionTraits&lt; OwnerOverlapCopyCommunication&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">EdgeProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the properties of an ede in the matrix graph.  <a href="a00114.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00293.html">VertexProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a node in the matrix graph.  <a href="a00293.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">PropertyGraphVertexPropertyMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">OverlapVertex</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00263.html">SparsityBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for building the sparsity pattern of the matrix using examineConnectivity.  <a href="a00263.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">BaseGalerkinProduct</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">GalerkinProduct</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">GalerkinProduct&lt; SequentialInformation &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">BaseConnectivityConstructor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">ConnectivityConstructor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">ConnectivityConstructor&lt; G, SequentialInformation &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">DirichletBoundarySetter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">DirichletBoundarySetter&lt; SequentialInformation &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">GlobalAggregatesMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">AggregatesGatherScatter</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">AggregatesPublisher</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">AggregatesPublisher&lt; T, O, OwnerOverlapCopyCommunication&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for publishing the aggregate number of the DOFs in the overlap to other processors and convert them to local indices.  <a href="a00015.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">AggregatesPublisher&lt; T, O, SequentialInformation &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html">MatrixGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (undirected) graph of a matrix.  <a href="a00166.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">SubGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subgraph of a graph.  <a href="a00264.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00294.html">VertexPropertiesGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches properties to the vertices of a graph.  <a href="a00294.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">PropertiesGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches properties to the edges and vertices of a graph.  <a href="a00205.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">GraphVertexPropertiesSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to access the internal edge properties of a graph via <a class="el" href="a00127.html#a284519a4d7bdac73f26407e744a1e88e" title="Get the properties associated to a vertex.">operator[]()</a>  <a href="a00127.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">GraphEdgePropertiesSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to access the internal vertex properties of a graph via <a class="el" href="a00126.html#af9f8710842abac2fc96c2a48b86e8970" title="Get the properties associated to a vertex.">operator[]()</a>  <a href="a00126.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">PropertiesGraphCreator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">PropertiesGraphCreator&lt; M, SolverCategory::sequential &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">PropertiesGraphCreator&lt; M, SolverCategory::overlapping &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">PropertiesGraphCreator&lt; M, SolverCategory::nonoverlapping &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">Hierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hierarchy of coantainers (e.g. matrices or vectors)  <a href="a00128.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">MatrixHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The hierarchies build by the coarsening process.  <a href="a00167.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">CoarsenCriterion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The criterion describing the stop criteria for the coarsening process.  <a href="a00054.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">IndicesCoarsener</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">ParallelIndicesCoarsener</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">IndicesCoarsener&lt; OwnerOverlapCopyCommunication&lt; G, L &gt;, E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsen Indices in the parallel case.  <a href="a00134.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">IndicesCoarsener&lt; SequentialInformation, E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsen Indices in the sequential case.  <a href="a00135.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">KAmgTwoGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two grid operator for <a class="el" href="a00031.html" title="Parallel algebraic multigrid based on agglomeration.">AMG</a> with Krylov cycle.  <a href="a00149.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">KAMG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an algebraic multigrid method using a Krylov-cycle.  <a href="a00148.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">DependencyParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00202.html" title="All parameters for AMG.">Parameters</a> needed to check whether a node depends on another.  <a href="a00100.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">AggregationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00202.html" title="All parameters for AMG.">Parameters</a> needed for the aggregation process,.  <a href="a00018.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">CoarseningParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00202.html" title="All parameters for AMG.">Parameters</a> for the complete coarsening process.  <a href="a00055.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html">Parameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All parameters for <a class="el" href="a00031.html" title="Parallel algebraic multigrid based on agglomeration.">AMG</a>.  <a href="a00202.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html">SequentialInformation</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00295.html">VertexVisitedTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag idnetifying the visited property of a vertex.  <a href="a00295.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html">RandomAccessBundledPropertyMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property map that extracts one property out of a bundle using <a class="el" href="a00372.html#ga12ef2c1377e445577a0a1f967272ccdb" title="Get the property for a key.">operator[]()</a>  <a href="a00215.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">AggregateRenumberer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">DefaultSmootherArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default class for the smoother arguments.  <a href="a00098.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html">SmootherTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for getting the attribute class of a smoother.  <a href="a00258.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html">SmootherTraits&lt; BlockPreconditioner&lt; X, Y, C, T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">SmootherTraits&lt; NonoverlappingBlockPreconditioner&lt; C, T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">DefaultConstructionArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction Arguments for the default smoothers.  <a href="a00096.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">ConstructionArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">DefaultParallelConstructionArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">ConstructionTraits&lt; SeqSSOR&lt; M, X, Y, l &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00250.html" title="Sequential SSOR preconditioner.">SeqSSOR</a> smoother.  <a href="a00090.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">ConstructionTraits&lt; SeqSOR&lt; M, X, Y, l &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00249.html" title="Sequential SOR preconditioner.">SeqSOR</a> smoother.  <a href="a00089.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">ConstructionTraits&lt; SeqJac&lt; M, X, Y, l &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00234.html" title="The sequential jacobian preconditioner.">SeqJac</a> smoother.  <a href="a00087.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">ConstructionTraits&lt; SeqILU0&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00233.html" title="Sequential ILU(n) preconditioner.">SeqILUn</a> smoother.  <a href="a00085.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">ConstructionArgs&lt; SeqILUn&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">ConstructionTraits&lt; SeqILUn&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00234.html" title="The sequential jacobian preconditioner.">SeqJac</a> smoother.  <a href="a00086.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">ConstructionTraits&lt; ParSSOR&lt; M, X, Y, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00203.html" title="A parallel SSOR preconditioner.">ParSSOR</a> smoother.  <a href="a00084.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">ConstructionTraits&lt; BlockPreconditioner&lt; X, Y, C, T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">ConstructionTraits&lt; NonoverlappingBlockPreconditioner&lt; C, T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00253.html">SmootherApplier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for applying the smoothers.  <a href="a00253.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00257.html">SmootherApplier&lt; SeqSOR&lt; M, X, Y, l &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00254.html">SmootherApplier&lt; BlockPreconditioner&lt; X, Y, C, SeqSOR&lt; M, X, Y, l &gt; &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00255.html">SmootherApplier&lt; NonoverlappingBlockPreconditioner&lt; C, SeqSOR&lt; M, X, Y, l &gt; &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00256.html">SmootherApplier&lt; SeqOverlappingSchwarz&lt; M, X, MultiplicativeSchwarzMode, MS, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00246.html">SeqOverlappingSchwarzSmootherArgs</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00261.html">SmootherTraits&lt; SeqOverlappingSchwarz&lt; M, X, TM, TS, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">ConstructionArgs&lt; SeqOverlappingSchwarz&lt; M, X, TM, TS, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">ConstructionTraits&lt; SeqOverlappingSchwarz&lt; M, X, TM, TS, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00284.html">Transfer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00286.html">Transfer&lt; V, V1, SequentialInformation &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html">Transfer&lt; V, V1, OwnerOverlapCopyCommunication&lt; T1, T2 &gt; &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga39c17e7d1ee389a75a36d8713dc96df5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00372.html#gga39c17e7d1ee389a75a36d8713dc96df5ad6b62d6d5abdcb2557c2a3a69feccdb0">MAX_PROCESSES</a> =  72000
 }</td></tr>
<tr class="memitem:gacf6f2fe996122d7c9d139e86a84957f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00372.html#gacf6f2fe996122d7c9d139e86a84957f7">AccumulationMode</a> { <a class="el" href="a00372.html#ggacf6f2fe996122d7c9d139e86a84957f7a5c5f5e0aa08de3ed0d0fe8cec4838260">noAccu</a> =  0, 
<a class="el" href="a00372.html#ggacf6f2fe996122d7c9d139e86a84957f7a4fe2fe3869543e6e15fc480bea94909a">atOnceAccu</a> = 1, 
<a class="el" href="a00372.html#ggacf6f2fe996122d7c9d139e86a84957f7a69257c9fc3443058ecc8d3d542fe0b0a">successiveAccu</a> = 2
 }</td></tr>
<tr class="memdesc:gacf6f2fe996122d7c9d139e86a84957f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifiers for the different accumulation modes.  <a href="a00372.html#gacf6f2fe996122d7c9d139e86a84957f7">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3b1322dc105dc48e2cfbb19bdc157416"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3b1322dc105dc48e2cfbb19bdc157416"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00372.html#ga3b1322dc105dc48e2cfbb19bdc157416">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a00017.html">AggregationCriterion</a>&lt; T &gt; &amp;criterion)</td></tr>
<tr class="memitem:gaf619ca4d1318ace19831096270fb506c"><td class="memTemplParams" colspan="2">template&lt;class G , class C &gt; </td></tr>
<tr class="memitem:gaf619ca4d1318ace19831096270fb506c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00372.html#gaf619ca4d1318ace19831096270fb506c">buildDependency</a> (G &amp;graph, const typename C::Matrix &amp;matrix, C criterion, bool finestLevel)</td></tr>
<tr class="memdesc:gaf619ca4d1318ace19831096270fb506c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the dependency of the matrix graph.  <a href="a00372.html#gaf619ca4d1318ace19831096270fb506c"></a><br/></td></tr>
<tr class="memitem:ga67437d2f75e7e1216ee57306825332be"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga67437d2f75e7e1216ee57306825332be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00372.html#ga67437d2f75e7e1216ee57306825332be">printAggregates2d</a> (const <a class="el" href="a00013.html">AggregatesMap</a>&lt; V &gt; &amp;aggregates, int n, int m, std::ostream &amp;os)</td></tr>
<tr class="memitem:gabfdb505d54f97595d5b559f9493978b1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00372.html#gabfdb505d54f97595d5b559f9493978b1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a00114.html">EdgeProperties</a> &amp;props)</td></tr>
<tr class="memitem:gab001191f50333ad683c2faeb8de5e4d2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00372.html#gab001191f50333ad683c2faeb8de5e4d2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a00293.html">VertexProperties</a> &amp;props)</td></tr>
<tr class="memitem:ga8c84915dd8eafb315ce76b1f689f1cf3"><td class="memTemplParams" colspan="2">template&lt;class G , class V &gt; </td></tr>
<tr class="memitem:ga8c84915dd8eafb315ce76b1f689f1cf3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00372.html#ga8c84915dd8eafb315ce76b1f689f1cf3">visitNeighbours</a> (const G &amp;graph, const typename G::VertexDescriptor &amp;vertex, V &amp;visitor)</td></tr>
<tr class="memdesc:ga8c84915dd8eafb315ce76b1f689f1cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all neighbour vertices of a vertex in a graph.  <a href="a00372.html#ga8c84915dd8eafb315ce76b1f689f1cf3"></a><br/></td></tr>
<tr class="memitem:gaf0cdf39d904dcf79a833a80b0f08a9e0"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C1 &gt; </td></tr>
<tr class="memitem:gaf0cdf39d904dcf79a833a80b0f08a9e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00372.html#gaf0cdf39d904dcf79a833a80b0f08a9e0">repartitionAndDistributeMatrix</a> (const M &amp;origMatrix, M &amp;newMatrix, <a class="el" href="a00252.html">SequentialInformation</a> &amp;origSequentialInformationomm, <a class="el" href="a00252.html">SequentialInformation</a> *&amp;newComm, <a class="el" href="a00219.html">RedistributeInformation</a>&lt; <a class="el" href="a00252.html">SequentialInformation</a> &gt; &amp;ri, int nparts, C1 &amp;criterion)</td></tr>
<tr class="memitem:ga928018044a608d5e9528f06ff7b35ca6"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C , typename C1 &gt; </td></tr>
<tr class="memitem:ga928018044a608d5e9528f06ff7b35ca6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00372.html#ga928018044a608d5e9528f06ff7b35ca6">repartitionAndDistributeMatrix</a> (const M &amp;origMatrix, M &amp;newMatrix, C &amp;origComm, C *&amp;newComm, <a class="el" href="a00219.html">RedistributeInformation</a>&lt; C &gt; &amp;ri, int nparts, C1 &amp;criterion)</td></tr>
<tr class="memitem:gae0fb8cf8ff6664506f4ce6e4ae3952ea"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gae0fb8cf8ff6664506f4ce6e4ae3952ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00372.html#gae0fb8cf8ff6664506f4ce6e4ae3952ea">repartitionAndDistributeMatrix</a> (M &amp;origMatrix, M &amp;newMatrix, <a class="el" href="a00252.html">SequentialInformation</a> &amp;origComm, <a class="el" href="a00252.html">SequentialInformation</a> &amp;newComm, <a class="el" href="a00219.html">RedistributeInformation</a>&lt; <a class="el" href="a00252.html">SequentialInformation</a> &gt; &amp;ri)</td></tr>
<tr class="memitem:a577d044e1622cb386cd4f6821ac63169"><td class="memTemplParams" colspan="2">template&lt;class G , class I , class V &gt; </td></tr>
<tr class="memitem:a577d044e1622cb386cd4f6821ac63169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00366.html#a577d044e1622cb386cd4f6821ac63169">renumberAggregates</a> (const G &amp;graph, I <a class="el" href="a00328.html#ac28efa16fb8062e271f8b7a373cc1734">index</a>, I endIndex, V &amp;visitedMap, <a class="el" href="a00013.html">AggregatesMap</a>&lt; typename G::VertexDescriptor &gt; &amp;aggregates)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a577d044e1622cb386cd4f6821ac63169"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class I , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Amg::renumberAggregates </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>endIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>visitedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AggregatesMap&lt; typename G::VertexDescriptor &gt; &amp;&#160;</td>
          <td class="paramname"><em>aggregates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00328.html#ac28efa16fb8062e271f8b7a373cc1734">index</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 4 2012 12:02:19 for dune-istl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
