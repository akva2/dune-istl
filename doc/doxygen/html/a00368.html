<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>dune-istl: Iterative Solvers Template Library (ISTL)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Iterative Solvers Template Library (ISTL)</div>  </div>
</div><!--header-->
<div class="contents">

<p>Iterative Solvers supporting block recursive matrix and vector classes at compile time.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Iterative Solvers Template Library (ISTL):</div>
<div class="dyncontent">
<center><table><tr><td><img src="a00368.png" border="0" alt="" usemap="#a00368"/>
<map name="a00368" id="a00368">
<area shape="rect" id="node1" href="a00369.html" title="Matrix and Vector classes that support a block recursive structure capable of representing the natura..." alt="" coords="229,5,400,51"/><area shape="rect" id="node2" href="a00375.html" title="Iterative Solvers" alt="" coords="256,75,373,104"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00369"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00369.html">Sparse Matrix and Vector classes</a></td></tr>
<tr class="memdesc:a00369"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00156.html" title="A generic dynamic dense matrix.">Matrix</a> and Vector classes that support a block recursive structure capable of representing the natural structure from Finite Element discretisations. <br/></td></tr>
<tr class="memitem:a00375"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00375.html">Iterative Solvers</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00356"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00356.html">superlu.hh</a></td></tr>
<tr class="memdesc:a00356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes for using SuperLU with ISTL matrices. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">Dune::ILUSubdomainSolver&lt; M, X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class encapsulating common algorithms of <a class="el" href="a00129.html" title="Exact subdomain solver using ILU(p) with appropriate p.">ILU0SubdomainSolver</a> and <a class="el" href="a00130.html">ILUNSubdomainSolver</a>.  <a href="a00131.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">Dune::ILU0SubdomainSolver&lt; M, X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact subdomain solver using ILU(p) with appropriate p.  <a href="a00129.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">Dune::ILUNSubdomainSolver&lt; M, X, Y &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">Dune::ISTLError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">derive error class from the base class in common  <a href="a00144.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">Dune::SuperLU&lt; Matrix &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">Dune::SuperLUSolveChooser&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">Dune::SuperLUDenseMatChooser&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html">Dune::SuperLUQueryChooser&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">Dune::QuerySpaceChooser&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">Dune::SuperLUDenseMatChooser&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00273.html">Dune::SuperLUSolveChooser&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">Dune::QuerySpaceChooser&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SuperLu Solver.  <a href="a00266.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6ffa7104c573c6b114387fef2f155541"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ga6ffa7104c573c6b114387fef2f155541"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00368.html#ga6ffa7104c573c6b114387fef2f155541">Dune::ILUSubdomainSolver&lt; M, X, Y &gt;::copyToLocalMatrix</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, S &amp;rowset)</td></tr>
<tr class="memdesc:ga6ffa7104c573c6b114387fef2f155541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the local part of the global matrix to ILU.  <a href="#ga6ffa7104c573c6b114387fef2f155541"></a><br/></td></tr>
<tr class="memitem:gafa21731f06b876f98d9431bb7bd20759"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:gafa21731f06b876f98d9431bb7bd20759"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00368.html#gafa21731f06b876f98d9431bb7bd20759">Dune::ILU0SubdomainSolver&lt; M, X, Y &gt;::setSubMatrix</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, S &amp;rowset)</td></tr>
<tr class="memdesc:gafa21731f06b876f98d9431bb7bd20759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data of the local problem.  <a href="#gafa21731f06b876f98d9431bb7bd20759"></a><br/></td></tr>
<tr class="memitem:ga73c6843e677895d542ad0453c6097d3e"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ga73c6843e677895d542ad0453c6097d3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00368.html#ga73c6843e677895d542ad0453c6097d3e">Dune::ILUNSubdomainSolver&lt; M, X, Y &gt;::setSubMatrix</a> (const M &amp;<a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a>, S &amp;rowset)</td></tr>
<tr class="memdesc:ga73c6843e677895d542ad0453c6097d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data of the local problem.  <a href="#ga73c6843e677895d542ad0453c6097d3e"></a><br/></td></tr>
<tr class="memitem:gab59d676b8b83f0cb71652f1ccc0f43b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#gab59d676b8b83f0cb71652f1ccc0f43b9">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::~SuperLU</a> ()</td></tr>
<tr class="memitem:ga9c28ebf8665b9c0127cbd36d5195c629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#ga9c28ebf8665b9c0127cbd36d5195c629">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::free</a> ()</td></tr>
<tr class="memdesc:ga9c28ebf8665b9c0127cbd36d5195c629"><td class="mdescLeft">&#160;</td><td class="mdescRight">free allocated space.  <a href="#ga9c28ebf8665b9c0127cbd36d5195c629"></a><br/></td></tr>
<tr class="memitem:ga706d1e074d3b6238b9c94265effba117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#ga706d1e074d3b6238b9c94265effba117">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::SuperLU</a> (const Matrix &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, bool verbose=false)</td></tr>
<tr class="memdesc:ga706d1e074d3b6238b9c94265effba117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <a class="el" href="a00265.html">SuperLU</a> solver.  <a href="#ga706d1e074d3b6238b9c94265effba117"></a><br/></td></tr>
<tr class="memitem:gaa9222fafc702a8c38373c13c15ee8c90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#gaa9222fafc702a8c38373c13c15ee8c90">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::SuperLU</a> ()</td></tr>
<tr class="memdesc:gaa9222fafc702a8c38373c13c15ee8c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty default constructor.  <a href="#gaa9222fafc702a8c38373c13c15ee8c90"></a><br/></td></tr>
<tr class="memitem:ga7c56b8a2baa7fc4853a211eeaad40870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#ga7c56b8a2baa7fc4853a211eeaad40870">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::setVerbosity</a> (bool v)</td></tr>
<tr class="memitem:gaa9d13756c765d49cde01e83f54f9b305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#gaa9d13756c765d49cde01e83f54f9b305">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::setMatrix</a> (const Matrix &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>)</td></tr>
<tr class="memdesc:gaa9d13756c765d49cde01e83f54f9b305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize data from given matrix.  <a href="#gaa9d13756c765d49cde01e83f54f9b305"></a><br/></td></tr>
<tr class="memitem:ga0e1369b957cc974e747743445c8da82e"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ga0e1369b957cc974e747743445c8da82e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00368.html#ga0e1369b957cc974e747743445c8da82e">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::setSubMatrix</a> (const Matrix &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const S &amp;rowIndexSet)</td></tr>
<tr class="memitem:ga286c6211054fe8257902318590eb5123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#ga286c6211054fe8257902318590eb5123">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::apply</a> (domain_type &amp;x, range_type &amp;b, InverseOperatorResult &amp;res)</td></tr>
<tr class="memdesc:ga286c6211054fe8257902318590eb5123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply inverse operator,.   <a href="#ga286c6211054fe8257902318590eb5123"></a><br/></td></tr>
<tr class="memitem:ga200fe7744e37060405a4b14398e5c6fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html#ga200fe7744e37060405a4b14398e5c6fc">Dune::SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;::apply</a> (T *x, T *b)</td></tr>
<tr class="memdesc:ga200fe7744e37060405a4b14398e5c6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply SuperLu to C arrays.  <a href="#ga200fe7744e37060405a4b14398e5c6fc"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Iterative Solvers supporting block recursive matrix and vector classes at compile time. </p>
<p>The Iterative Solver Template Library applies generic programming in C++ to the domain of iterative solvers of linear systems stemming from finite element discretizations. Those discretizations exhibit a lot of structure, e.g:</p>
<ol>
<li>
Certain discretizations for systems of PDEs or higher order methods result in matrices where individual entries are replaced by small blocks, say of size <img class="formulaInl" alt="$2\times 2$" src="form_0.png"/> or <img class="formulaInl" alt="$4\times 4$" src="form_1.png"/>. Dense blocks of different sizes e.g. arise in <img class="formulaInl" alt="$hp$" src="form_2.png"/> Discontinuous Galerkin discretization methods. It is straightforward and efficient to treat these small dense blocks as fully coupled and solve them with direct methods within the iterative method. </li>
<li>
Equation-wise ordering for systems results in matrices having an <img class="formulaInl" alt="$n\times n$" src="form_3.png"/> block structure where <img class="formulaInl" alt="$n$" src="form_4.png"/> corresponds to the number of variables in the PDE and the blocks themselves are large and sparse. As an example we mention the Stokes system.  </li>
<li>
Other discretisation, e.~g. those of reaction/diffusion systems, produce sparse matrices whose blocks are sparse matrices of small dense blocks, </li>
</ol>
<p>Our matrix and vector interface supports a block recursive structure. Each sparse matrix entry can itself be either a sparse or a small dense matrix.</p>
<p>The solvers use this recursive block structure via template meta programming at compile time.</p>
<p>ISTL consists of the <a class="el" href="a00369.html">matrix and vector API</a> and the <a class="el" href="a00375.html">solvers</a> which use the <a class="el" href="a00373.html">Preconditioners</a> preconditioners. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga286c6211054fe8257902318590eb5123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00266.html#aafc35ea2d3511c7ca38d2a8e936388bd">domain_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00266.html#a30206cad77f71467d7326845f889220d">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00137.html">InverseOperatorResult</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply inverse operator,.  </p>
<p><dl class="section warning"><dt>Warning:</dt><dd>Note: right hand side b may be overwritten!</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The left hand side to store the result in. </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side </td></tr>
    <tr><td class="paramname">res</td><td>Object to store the statistics about applying the operator. </td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>References <a class="el" href="a00137.html#afefe366c3c36a5a9a599c2ba4c711ab6">Dune::InverseOperatorResult::converged</a>, <a class="el" href="a00137.html#ac42bf46e67cf01e6eb29f2b05bdb9f42">Dune::InverseOperatorResult::iterations</a>, <a class="el" href="a00156.html#a77a862040f252cfc7e2f863ffd63ea5c">Dune::Matrix&lt; T, A &gt;::M()</a>, <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, and <a class="el" href="a00156.html#ae2d1358bee5ae1954b7b573fa0e6a260">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

</div>
</div>
<a class="anchor" id="ga200fe7744e37060405a4b14398e5c6fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply SuperLu to C arrays. </p>

<p>References <a class="el" href="a00156.html#a77a862040f252cfc7e2f863ffd63ea5c">Dune::Matrix&lt; T, A &gt;::M()</a>, <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, and <a class="el" href="a00156.html#ae2d1358bee5ae1954b7b573fa0e6a260">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ffa7104c573c6b114387fef2f155541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00131.html">Dune::ILUSubdomainSolver</a>&lt; M, X, Y &gt;::copyToLocalMatrix </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>rowset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the local part of the global matrix to ILU. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">rowset</td><td>The global indices of the local problem. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c28ebf8665b9c0127cbd36d5195c629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free allocated space. </p>
<dl class="section warning"><dt>Warning:</dt><dd>later calling apply will result in an error. </dd></dl>

<p>References <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9d13756c765d49cde01e83f54f9b305"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00266.html#a69bd81ae36fb356c409f39301e935fcb">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize data from given matrix. </p>

<p>References <a class="el" href="a00156.html#a77a862040f252cfc7e2f863ffd63ea5c">Dune::Matrix&lt; T, A &gt;::M()</a>, <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, and <a class="el" href="a00156.html#ae2d1358bee5ae1954b7b573fa0e6a260">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

</div>
</div>
<a class="anchor" id="gafa21731f06b876f98d9431bb7bd20759"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00129.html">Dune::ILU0SubdomainSolver</a>&lt; M, X, Y &gt;::setSubMatrix </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>rowset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data of the local problem. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">rowset</td><td>The global indices of the local problem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type of the set with the indices. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00377.html#gae67699f4a1392779203441b91402a834">Dune::bilu0_decomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="ga73c6843e677895d542ad0453c6097d3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00130.html">Dune::ILUNSubdomainSolver</a>&lt; M, X, Y &gt;::setSubMatrix </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>rowset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data of the local problem. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">rowset</td><td>The global indices of the local problem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type of the set with the indices. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00377.html#gab9180edeb5a71c5a5fa867a2b395e562">Dune::bilu_decomposition()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e1369b957cc974e747743445c8da82e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::setSubMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00266.html#a69bd81ae36fb356c409f39301e935fcb">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>rowIndexSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00156.html#a77a862040f252cfc7e2f863ffd63ea5c">Dune::Matrix&lt; T, A &gt;::M()</a>, <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, and <a class="el" href="a00156.html#ae2d1358bee5ae1954b7b573fa0e6a260">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c56b8a2baa7fc4853a211eeaad40870"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::setVerbosity </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga706d1e074d3b6238b9c94265effba117"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::SuperLU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00266.html#a69bd81ae36fb356c409f39301e935fcb">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the <a class="el" href="a00265.html">SuperLU</a> solver. </p>
<p>During the construction the matrix will be decomposed. That means that in each apply call forward and backward substitutions take place (and no decomposition). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix of the system to solve. </td></tr>
    <tr><td class="paramname">verbose</td><td>If true some statistics are printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9222fafc702a8c38373c13c15ee8c90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::SuperLU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty default constructor. </p>
<p>Use setMatrix to tell <a class="el" href="a00265.html">SuperLU</a> for what matrix it solves. </p>

</div>
</div>
<a class="anchor" id="gab59d676b8b83f0cb71652f1ccc0f43b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00265.html">Dune::SuperLU</a>&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::~SuperLU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00156.html#a77a862040f252cfc7e2f863ffd63ea5c">Dune::Matrix&lt; T, A &gt;::M()</a>, <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, and <a class="el" href="a00156.html#ae2d1358bee5ae1954b7b573fa0e6a260">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 4 2012 12:02:18 for dune-istl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
