<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>dune-istl: Preconditioners</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Preconditioners</div>  </div>
<div class="ingroups"><a class="el" href="a00375.html">Iterative Solvers</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Preconditioners:</div>
<div class="dyncontent">
<center><table><tr><td><img src="a00373.png" border="0" alt="" usemap="#a00373"/>
<map name="a00373" id="a00373">
<area shape="rect" id="node3" href="a00372.html" title="A Parallel Algebraic Multigrid based on Agglomeration." alt="" coords="400,5,523,51"/><area shape="rect" id="node4" href="a00374.html" title="Scalar products for the use in iterative solvers." alt="" coords="405,75,517,104"/><area shape="rect" id="node2" href="a00375.html" title="Iterative Solvers" alt="" coords="5,44,123,73"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00372"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00372.html">Parallel Algebraic Multigrid</a></td></tr>
<tr class="memdesc:a00372"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Parallel Algebraic Multigrid based on Agglomeration. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00337"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00337.html">overlappingschwarz.hh</a></td></tr>
<tr class="memdesc:a00337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains one level overlapping Schwarz preconditioners. <br/></td></tr>
<tr class="memitem:a00343"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00343.html">preconditioners.hh</a></td></tr>
<tr class="memdesc:a00343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define general preconditioner interface. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00366"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00366.html">Dune::Amg</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for <a class="el" href="a00265.html">SuperLU</a> Matrices representing the subdomains.  <a href="a00193.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">Dune::AdditiveSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that the tells the schwarz method to be additive.  <a href="a00009.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">Dune::MultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative.  <a href="a00180.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html">Dune::SymmetricMultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative and symmetric.  <a href="a00282.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">Dune::DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">Dune::OverlappingAssigner&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">Dune::OverlappingAssigner&lt; ILU0SubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00190.html">Dune::OverlappingAssigner&lt; ILUNSubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">Dune::AdditiveAdder&lt; S, T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">Dune::AdditiveAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">Dune::MultiplicativeAdder&lt; S, T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">Dune::AdderSelector&lt; T, X, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template meta program for choosing how to add the correction.  <a href="a00002.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">Dune::AdderSelector&lt; AdditiveSchwarzMode, X, S &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">Dune::AdderSelector&lt; MultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">Dune::AdderSelector&lt; SymmetricMultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">Dune::IteratorDirectionSelector&lt; T1, T2, forward &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping schwarz.  <a href="a00146.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">Dune::IteratorDirectionSelector&lt; T1, T2, false &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html">Dune::SeqOverlappingSchwarzApplier&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping schwarz.  <a href="a00236.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">Dune::SeqOverlappingSchwarzApplier&lt; SeqOverlappingSchwarz&lt; M, X, SymmetricMultiplicativeSchwarzMode, TD, TA &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00238.html">Dune::SeqOverlappingSchwarzAssembler&lt; T &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html">Dune::SeqOverlappingSchwarzAssembler&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">Dune::SeqOverlappingSchwarzAssembler&lt; SuperLU&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">Dune::SeqOverlappingSchwarzAssemblerILUBase&lt; M, X, Y &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00240.html">Dune::SeqOverlappingSchwarzAssembler&lt; ILU0SubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">Dune::SeqOverlappingSchwarzAssembler&lt; ILUNSubdomainSolver&lt; M, X, Y &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential overlapping Schwarz preconditioner.  <a href="a00235.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">Dune::SeqOverlappingSchwarzDomainSize&lt; M &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html">Dune::SeqOverlappingSchwarzDomainSize&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">Dune::Preconditioner&lt; X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matrix free definition of preconditioners.  <a href="a00204.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00250.html">Dune::SeqSSOR&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SSOR preconditioner.  <a href="a00250.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html">Dune::SeqSOR&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SOR preconditioner.  <a href="a00249.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html">Dune::SeqGS&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential Gauss Seidel preconditioner.  <a href="a00231.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00234.html">Dune::SeqJac&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequential jacobian preconditioner.  <a href="a00234.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">Dune::SeqILU0&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential ILU0 preconditioner.  <a href="a00232.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">Dune::SeqILUn&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential ILU(n) preconditioner.  <a href="a00233.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">Dune::Richardson&lt; X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00223.html" title="Richardson preconditioner.">Richardson</a> preconditioner.  <a href="a00223.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">Dune::ParSSOR&lt; M, X, Y, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel SSOR preconditioner.  <a href="a00203.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">Dune::BlockPreconditioner&lt; X, Y, C, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block parallel preconditioner.  <a href="a00045.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga680ecf80821212aaa8149d72eea3010e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga680ecf80821212aaa8149d72eea3010e">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::OverlappingSchwarzInitializer</a> (InitializerList &amp;il, const IndexSet &amp;indices, const subdomain_vector &amp;domains)</td></tr>
<tr class="memitem:ga01ce789c3fd3870dee0f0df52eac92c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga01ce789c3fd3870dee0f0df52eac92c5">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::addRowNnz</a> (const Iter &amp;<a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>)</td></tr>
<tr class="memitem:ga995ede9ec46c2990a1f249b4096a827a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga995ede9ec46c2990a1f249b4096a827a">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::allocate</a> ()</td></tr>
<tr class="memitem:gaaa15a5cfaf356e18737a7b429da0ca10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gaaa15a5cfaf356e18737a7b429da0ca10">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::countEntries</a> (const Iter &amp;<a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>, const CIter &amp;<a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>) const </td></tr>
<tr class="memitem:gafae896814cb04c1ed80b1f7c96570cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gafae896814cb04c1ed80b1f7c96570cb9">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::calcColstart</a> () const </td></tr>
<tr class="memitem:gab61afc8dc20933e7035753c995764db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gab61afc8dc20933e7035753c995764db3">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::copyValue</a> (const Iter &amp;<a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>, const CIter &amp;<a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>) const </td></tr>
<tr class="memitem:ga52b7faceab79855ba2c6e16ea6639ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga52b7faceab79855ba2c6e16ea6639ef5">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::createMatrix</a> () const </td></tr>
<tr class="memitem:ga6a680e2548b56a7dadc9f0269fd2bb7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga6a680e2548b56a7dadc9f0269fd2bb7b">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::IndexMap</a> ()</td></tr>
<tr class="memitem:gac38c2a9d650c270b58a6572b8d54292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gac38c2a9d650c270b58a6572b8d54292f">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::insert</a> (size_type grow)</td></tr>
<tr class="memitem:gafc9359c413a6fff9d9c12bd45ca81dfc"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gafc9359c413a6fff9d9c12bd45ca81dfc">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::find</a> (size_type grow) const </td></tr>
<tr class="memitem:ga4914e60d4ae3251d332a27b367b16280"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga4914e60d4ae3251d332a27b367b16280">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::find</a> (size_type grow)</td></tr>
<tr class="memitem:ga9f0cfc1c938e175df0a564b17ffcd2ab"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga9f0cfc1c938e175df0a564b17ffcd2ab">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::end</a> () const </td></tr>
<tr class="memitem:ga32f49a7bed697ba20cdad682abf7831b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga32f49a7bed697ba20cdad682abf7831b">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::end</a> ()</td></tr>
<tr class="memitem:ga9238ed1ea1ce3c4d2e40f77a9a56a87c"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga9238ed1ea1ce3c4d2e40f77a9a56a87c">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::begin</a> () const </td></tr>
<tr class="memitem:ga609c6c8a5bb36b65278f3107963f67a5"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga609c6c8a5bb36b65278f3107963f67a5">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::begin</a> ()</td></tr>
<tr class="memitem:gae92d3496d89061727cbb287f66353cb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gae92d3496d89061727cbb287f66353cb5">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;::SeqOverlappingSchwarz</a> (const matrix_type &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const rowtodomain_vector &amp;rowToDomain, field_type relaxationFactor=1, bool onTheFly_=true)</td></tr>
<tr class="memitem:ga8b6f1eb9ad0a1080f762446c800ee2ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga8b6f1eb9ad0a1080f762446c800ee2ef">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;::SeqOverlappingSchwarz</a> (const matrix_type &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const subdomain_vector &amp;subDomains, field_type relaxationFactor=1, bool onTheFly_=true)</td></tr>
<tr class="memdesc:ga8b6f1eb9ad0a1080f762446c800ee2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the overlapping Schwarz method.  <a href="#ga8b6f1eb9ad0a1080f762446c800ee2ef"></a><br/></td></tr>
<tr class="memitem:ga7c58b8ddb2f68420a0f9ea3b4642b771"><td class="memTemplParams" colspan="2">template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </td></tr>
<tr class="memitem:ga7c58b8ddb2f68420a0f9ea3b4642b771"><td class="memTemplItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00373.html#ga7c58b8ddb2f68420a0f9ea3b4642b771">Dune::SeqOverlappingSchwarzAssembler&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::assembleLocalProblems</a> (const RowToDomain &amp;rowToDomain, const matrix_type &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, Solvers &amp;solvers, const SubDomains &amp;domains, bool onTheFly)</td></tr>
<tr class="memitem:gadaa03d2a62f0be753c5e0c7091e1e6f0"><td class="memTemplParams" colspan="2">template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </td></tr>
<tr class="memitem:gadaa03d2a62f0be753c5e0c7091e1e6f0"><td class="memTemplItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00373.html#gadaa03d2a62f0be753c5e0c7091e1e6f0">Dune::SeqOverlappingSchwarzAssembler&lt; SuperLU&lt; T &gt; &gt;::assembleLocalProblems</a> (const RowToDomain &amp;rowToDomain, const matrix_type &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, Solvers &amp;solvers, const SubDomains &amp;domains, bool onTheFly)</td></tr>
<tr class="memitem:gad6302cd50d5db09119ee9de39e700ba6"><td class="memTemplParams" colspan="2">template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </td></tr>
<tr class="memitem:gad6302cd50d5db09119ee9de39e700ba6"><td class="memTemplItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00373.html#gad6302cd50d5db09119ee9de39e700ba6">Dune::SeqOverlappingSchwarzAssemblerILUBase&lt; M, X, Y &gt;::assembleLocalProblems</a> (const RowToDomain &amp;rowToDomain, const matrix_type &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, Solvers &amp;solvers, const SubDomains &amp;domains, bool onTheFly)</td></tr>
<tr class="memitem:ga7165b943ac63555d9be74469dd1bdf0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga7165b943ac63555d9be74469dd1bdf0c">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;::apply</a> (X &amp;v, const X &amp;d)</td></tr>
<tr class="memdesc:ga7165b943ac63555d9be74469dd1bdf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the precondtioner.  <a href="#ga7165b943ac63555d9be74469dd1bdf0c"></a><br/></td></tr>
<tr class="memitem:gab05914b838ce44fe41e06af143a46c76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gab05914b838ce44fe41e06af143a46c76">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::OverlappingAssigner</a> (std::size_t maxlength, const BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt; &amp;mat_, const X &amp;b_, Y &amp;x_)</td></tr>
<tr class="memdesc:gab05914b838ce44fe41e06af143a46c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#gab05914b838ce44fe41e06af143a46c76"></a><br/></td></tr>
<tr class="memitem:ga3572b55b5dd2bb5c9e401c759a6b8467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga3572b55b5dd2bb5c9e401c759a6b8467">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::deallocate</a> ()</td></tr>
<tr class="memdesc:ga3572b55b5dd2bb5c9e401c759a6b8467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory of the local vector.  <a href="#ga3572b55b5dd2bb5c9e401c759a6b8467"></a><br/></td></tr>
<tr class="memitem:ga4621a7b0691f6ead344f601601c2fc77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga4621a7b0691f6ead344f601601c2fc77">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::resetIndexForNextDomain</a> ()</td></tr>
<tr class="memdesc:ga4621a7b0691f6ead344f601601c2fc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the local index to zero.  <a href="#ga4621a7b0691f6ead344f601601c2fc77"></a><br/></td></tr>
<tr class="memitem:gad629dd82634eee7d4b4eb66f261d316f"><td class="memItemLeft" align="right" valign="top">DynamicVector&lt; K &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gad629dd82634eee7d4b4eb66f261d316f">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::lhs</a> ()</td></tr>
<tr class="memdesc:gad629dd82634eee7d4b4eb66f261d316f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local left hand side.  <a href="#gad629dd82634eee7d4b4eb66f261d316f"></a><br/></td></tr>
<tr class="memitem:gad0f8311457761bea12f65864eb22a0a3"><td class="memItemLeft" align="right" valign="top">DynamicVector&lt; K &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gad0f8311457761bea12f65864eb22a0a3">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::rhs</a> ()</td></tr>
<tr class="memdesc:gad0f8311457761bea12f65864eb22a0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local right hand side.  <a href="#gad0f8311457761bea12f65864eb22a0a3"></a><br/></td></tr>
<tr class="memitem:ga020550e60276e3d02fcaa0a7cccdeb7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga020550e60276e3d02fcaa0a7cccdeb7f">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::relaxResult</a> (field_type relax)</td></tr>
<tr class="memdesc:ga020550e60276e3d02fcaa0a7cccdeb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">relax the result.  <a href="#ga020550e60276e3d02fcaa0a7cccdeb7f"></a><br/></td></tr>
<tr class="memitem:gadd589bdc2211809ea5aeead12650c076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gadd589bdc2211809ea5aeead12650c076">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::operator()</a> (const size_type &amp;domainIndex)</td></tr>
<tr class="memdesc:gadd589bdc2211809ea5aeead12650c076"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate one entry of the local defect.  <a href="#gadd589bdc2211809ea5aeead12650c076"></a><br/></td></tr>
<tr class="memitem:ga1fb07aacdb1573f710b0304d25c81085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga1fb07aacdb1573f710b0304d25c81085">Dune::OverlappingAssigner&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::assignResult</a> (block_type &amp;res)</td></tr>
<tr class="memdesc:ga1fb07aacdb1573f710b0304d25c81085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block.  <a href="#ga1fb07aacdb1573f710b0304d25c81085"></a><br/></td></tr>
<tr class="memitem:ga9f99e68fe280cd951b063c5034f7f055"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga9f99e68fe280cd951b063c5034f7f055">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::OverlappingAssigner</a> (std::size_t maxlength, const BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const range_type &amp;b, range_type &amp;x)</td></tr>
<tr class="memdesc:ga9f99e68fe280cd951b063c5034f7f055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ga9f99e68fe280cd951b063c5034f7f055"></a><br/></td></tr>
<tr class="memitem:ga00aa57c278d7ae593f95662f311fa6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga00aa57c278d7ae593f95662f311fa6c6">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::deallocate</a> ()</td></tr>
<tr class="memdesc:ga00aa57c278d7ae593f95662f311fa6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory of the local vector.  <a href="#ga00aa57c278d7ae593f95662f311fa6c6"></a><br/></td></tr>
<tr class="memitem:gacf6930cc9d03fc7b978c36362d4238dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gacf6930cc9d03fc7b978c36362d4238dc">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::operator()</a> (const size_type &amp;domain)</td></tr>
<tr class="memdesc:gacf6930cc9d03fc7b978c36362d4238dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate one entry of the local defect.  <a href="#gacf6930cc9d03fc7b978c36362d4238dc"></a><br/></td></tr>
<tr class="memitem:ga0367fbcb988b7065acc5c3960f48ef3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga0367fbcb988b7065acc5c3960f48ef3d">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::relaxResult</a> (field_type relax)</td></tr>
<tr class="memdesc:ga0367fbcb988b7065acc5c3960f48ef3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">relax the result.  <a href="#ga0367fbcb988b7065acc5c3960f48ef3d"></a><br/></td></tr>
<tr class="memitem:gabb9fcfe124e441836e0c56b8f3180f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gabb9fcfe124e441836e0c56b8f3180f6c">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::assignResult</a> (block_type &amp;res)</td></tr>
<tr class="memdesc:gabb9fcfe124e441836e0c56b8f3180f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block.  <a href="#gabb9fcfe124e441836e0c56b8f3180f6c"></a><br/></td></tr>
<tr class="memitem:ga0746cf89c885736ae33cdb6f002b1b13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga0746cf89c885736ae33cdb6f002b1b13">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::resetIndexForNextDomain</a> ()</td></tr>
<tr class="memitem:gab12ab6a6a059d8ebb057b245e0d8b279"><td class="memItemLeft" align="right" valign="top">field_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gab12ab6a6a059d8ebb057b245e0d8b279">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::lhs</a> ()</td></tr>
<tr class="memdesc:gab12ab6a6a059d8ebb057b245e0d8b279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local left hand side.  <a href="#gab12ab6a6a059d8ebb057b245e0d8b279"></a><br/></td></tr>
<tr class="memitem:ga15694420b9015b1fbd603996e4a24f0e"><td class="memItemLeft" align="right" valign="top">field_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga15694420b9015b1fbd603996e4a24f0e">Dune::OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;::rhs</a> ()</td></tr>
<tr class="memdesc:ga15694420b9015b1fbd603996e4a24f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local right hand side.  <a href="#ga15694420b9015b1fbd603996e4a24f0e"></a><br/></td></tr>
<tr class="memitem:ga7a24b7bf122f654480690478c2cc80fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga7a24b7bf122f654480690478c2cc80fc">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::OverlappingAssignerILUBase</a> (std::size_t maxlength, const M &amp;<a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const Y &amp;b, X &amp;x)</td></tr>
<tr class="memdesc:ga7a24b7bf122f654480690478c2cc80fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ga7a24b7bf122f654480690478c2cc80fc"></a><br/></td></tr>
<tr class="memitem:ga9a7c6fd66dd0d12e3db397ec4318ae6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga9a7c6fd66dd0d12e3db397ec4318ae6a">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::deallocate</a> ()</td></tr>
<tr class="memdesc:ga9a7c6fd66dd0d12e3db397ec4318ae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory of the local vector.  <a href="#ga9a7c6fd66dd0d12e3db397ec4318ae6a"></a><br/></td></tr>
<tr class="memitem:ga85a5a216087e03197a0b64f7484bccb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga85a5a216087e03197a0b64f7484bccb5">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::operator()</a> (const size_type &amp;domain)</td></tr>
<tr class="memdesc:ga85a5a216087e03197a0b64f7484bccb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate one entry of the local defect.  <a href="#ga85a5a216087e03197a0b64f7484bccb5"></a><br/></td></tr>
<tr class="memitem:gad711654fd4e5f5e86f68e99795664119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gad711654fd4e5f5e86f68e99795664119">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::relaxResult</a> (field_type relax)</td></tr>
<tr class="memdesc:gad711654fd4e5f5e86f68e99795664119"><td class="mdescLeft">&#160;</td><td class="mdescRight">relax the result.  <a href="#gad711654fd4e5f5e86f68e99795664119"></a><br/></td></tr>
<tr class="memitem:gae600a61fbac4cd4fc97c2dc2e0eb17f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gae600a61fbac4cd4fc97c2dc2e0eb17f1">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::assignResult</a> (block_type &amp;res)</td></tr>
<tr class="memdesc:gae600a61fbac4cd4fc97c2dc2e0eb17f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block.  <a href="#gae600a61fbac4cd4fc97c2dc2e0eb17f1"></a><br/></td></tr>
<tr class="memitem:ga0f21fa6a8c50e4281aac39aa06ed442c"><td class="memItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga0f21fa6a8c50e4281aac39aa06ed442c">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::lhs</a> ()</td></tr>
<tr class="memdesc:ga0f21fa6a8c50e4281aac39aa06ed442c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local left hand side.  <a href="#ga0f21fa6a8c50e4281aac39aa06ed442c"></a><br/></td></tr>
<tr class="memitem:ga242dba5b5b746420469c028df5833224"><td class="memItemLeft" align="right" valign="top">Y &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga242dba5b5b746420469c028df5833224">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::rhs</a> ()</td></tr>
<tr class="memdesc:ga242dba5b5b746420469c028df5833224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local right hand side.  <a href="#ga242dba5b5b746420469c028df5833224"></a><br/></td></tr>
<tr class="memitem:ga4236f7c9f4d06105d1f2f2f4ded2ea95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga4236f7c9f4d06105d1f2f2f4ded2ea95">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::resetIndexForNextDomain</a> ()</td></tr>
<tr class="memdesc:ga4236f7c9f4d06105d1f2f2f4ded2ea95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the local index to zero.  <a href="#ga4236f7c9f4d06105d1f2f2f4ded2ea95"></a><br/></td></tr>
<tr class="memitem:ga7760fb64484362a70ae7744a4dd0d6d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga7760fb64484362a70ae7744a4dd0d6d4">Dune::AdditiveAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;::AdditiveAdder</a> (BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;v, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;x, OverlappingAssigner&lt; S &gt; &amp;assigner, const T &amp;relax_)</td></tr>
<tr class="memitem:ga638ab5d22970e302b0bf78a0baa11199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga638ab5d22970e302b0bf78a0baa11199">Dune::AdditiveAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;::operator()</a> (const size_type &amp;domain)</td></tr>
<tr class="memitem:ga5b8a983b0ef272f0a71e8341587aadd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga5b8a983b0ef272f0a71e8341587aadd0">Dune::AdditiveAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;::axpy</a> ()</td></tr>
<tr class="memitem:ga269a3355821d51265d5c78fa2b411b2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga269a3355821d51265d5c78fa2b411b2a">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;::MultiplicativeAdder</a> (BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;v, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;x, OverlappingAssigner&lt; S &gt; &amp;assigner_, const T &amp;relax_)</td></tr>
<tr class="memitem:gaa4dab85e4fba47077cb0142e759bd60e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#gaa4dab85e4fba47077cb0142e759bd60e">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;::operator()</a> (const size_type &amp;domain)</td></tr>
<tr class="memitem:ga8bab9ba59de245a268826cfce5d82a76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html#ga8bab9ba59de245a268826cfce5d82a76">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, A &gt; &gt;::axpy</a> ()</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>All of our <a class="el" href="a00375.html">Krylow solvers</a> are preconditioned versions. There are sequential preconditioners (e,g. SeqJacobi, <a class="el" href="a00249.html" title="Sequential SOR preconditioner.">SeqSOR</a>, <a class="el" href="a00250.html" title="Sequential SSOR preconditioner.">SeqSSOR</a>) as well as parallel preconditioners (e.g. AMG, <a class="el" href="a00045.html" title="Block parallel preconditioner.">BlockPreconditioner</a>) available for plugging them into the solvers together with matching ScalarProducts.</p>
<p>Some of the available perconditioners (e.g. SeqJacobi, <a class="el" href="a00249.html" title="Sequential SOR preconditioner.">SeqSOR</a>, <a class="el" href="a00250.html" title="Sequential SSOR preconditioner.">SeqSSOR</a>)) may be given an aditional int as a template parameter, the block recursion level. These preconditioners can be used on blockrecursive matrices with an arbitrary hierarchy depths (eg. <a class="el" href="a00040.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a>&lt;BCRSMatrix&lt;FieldMatrix,n,m&gt; &gt; &gt;. Given a block recursion level <img class="formulaInl" alt="$k$" src="form_32.png"/> those preconditioners work as normal on the offdiagonal blocks, treating them as traditional matrix entries. For the diagonal values a special procedure applies: If <img class="formulaInl" alt="$k>1$" src="form_33.png"/> the diagonal is treated as a matrix itself and the preconditioner is applied recursively on the matrix representing the diagonal value <img class="formulaInl" alt="$D=A_{ii}$" src="form_34.png"/> with block level <img class="formulaInl" alt="$k-1$" src="form_35.png"/>. For the case that <img class="formulaInl" alt="$k=1$" src="form_36.png"/> the diagonal is treated as a matrix entry resulting in a linear solve or an identity operation depending on the algorithm. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7760fb64484362a70ae7744a4dd0d6d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">Dune::AdditiveAdder</a>&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::AdditiveAdder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00046.html">BlockVector</a>&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00046.html">BlockVector</a>&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00187.html">OverlappingAssigner</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>assigner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>relax_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga01ce789c3fd3870dee0f0df52eac92c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::addRowNnz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00193.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga995ede9ec46c2990a1f249b4096a827a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7165b943ac63555d9be74469dd1bdf0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X, class TM , class TD , class TA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00235.html">Dune::SeqOverlappingSchwarz</a>&lt; M, X, TM, TD, TA &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the precondtioner. </p>
<p>Apply one step of the preconditioner to the system A(v)=d.  On entry v=0 and d=b-A(x) (although this might not be computed in that way. On exit v contains the update, i.e one step computes <img class="formulaInl" alt="$ v = M^{-1} d $" src="form_37.png"/> where <img class="formulaInl" alt="$ M $" src="form_38.png"/> is the approximate inverse of the operator <img class="formulaInl" alt="$ A $" src="form_39.png"/> characterizing the preconditioner. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The update to be computed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">d</td><td>The current defect. </td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="a00204.html#a05b45208eec670e82b65bbc8e2601af0">Dune::Preconditioner&lt; X, X &gt;</a>.</p>

<p>References <a class="el" href="a00236.html#a6076729a19dd0e0099a52b0fb177228d">Dune::SeqOverlappingSchwarzApplier&lt; T &gt;::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c58b8ddb2f68420a0f9ea3b4642b771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00238.html">Dune::SeqOverlappingSchwarzAssembler</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::assembleLocalProblems </td>
          <td>(</td>
          <td class="paramtype">const RowToDomain &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00239.html#a5181484d12ef77e43466ca3990a78f8a">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solvers &amp;&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubDomains &amp;&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadaa03d2a62f0be753c5e0c7091e1e6f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00238.html">Dune::SeqOverlappingSchwarzAssembler</a>&lt; SuperLU&lt; T &gt; &gt;::assembleLocalProblems </td>
          <td>(</td>
          <td class="paramtype">const RowToDomain &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00242.html#ab5dbe471a07704d16db909b8b52a564c">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solvers &amp;&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubDomains &amp;&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="a00360.html#a8504f1a06af26dfaf590e38c5110a368">Dune::copyToSuperMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6302cd50d5db09119ee9de39e700ba6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00243.html">Dune::SeqOverlappingSchwarzAssemblerILUBase</a>&lt; M, X, Y &gt;::assembleLocalProblems </td>
          <td>(</td>
          <td class="paramtype">const RowToDomain &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00243.html#a5aee4c2388849de9ba7ef2f6afdc69f6">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solvers &amp;&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubDomains &amp;&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1fb07aacdb1573f710b0304d25c81085"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::assignResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00188.html#ad83ac6b37b8e2fe71ad7f7a5feb6226d">block_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block. </p>

</div>
</div>
<a class="anchor" id="gabb9fcfe124e441836e0c56b8f3180f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::assignResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00191.html#abc311981cde936f04fb9f2e04915dffd">block_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block. </p>

</div>
</div>
<a class="anchor" id="gae600a61fbac4cd4fc97c2dc2e0eb17f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::assignResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00192.html#a6f90e2c8bdeb34e45da12c03ce4c78c4">block_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block. </p>

</div>
</div>
<a class="anchor" id="ga5b8a983b0ef272f0a71e8341587aadd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">Dune::AdditiveAdder</a>&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::axpy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8bab9ba59de245a268826cfce5d82a76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00178.html">Dune::MultiplicativeAdder</a>&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::axpy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga609c6c8a5bb36b65278f3107963f67a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::iterator <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9238ed1ea1ce3c4d2e40f77a9a56a87c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::const_iterator <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gafae896814cb04c1ed80b1f7c96570cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::calcColstart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab61afc8dc20933e7035753c995764db3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::copyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00193.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00193.html#a1992e4a416cb68438b2c51122f4af880">CIter</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaaa15a5cfaf356e18737a7b429da0ca10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::countEntries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00193.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00193.html#a1992e4a416cb68438b2c51122f4af880">CIter</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga52b7faceab79855ba2c6e16ea6639ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::createMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3572b55b5dd2bb5c9e401c759a6b8467"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates memory of the local vector. </p>

</div>
</div>
<a class="anchor" id="ga00aa57c278d7ae593f95662f311fa6c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates memory of the local vector. </p>
<dl class="section warning"><dt>Warning:</dt><dd>memory is released by the destructor as this Functor is copied and the copy needs to still have the data. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a7c6fd66dd0d12e3db397ec4318ae6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates memory of the local vector. </p>
<dl class="section warning"><dt>Warning:</dt><dd>memory is released by the destructor as this Functor is copied and the copy needs to still have the data. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32f49a7bed697ba20cdad682abf7831b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::iterator <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9f0cfc1c938e175df0a564b17ffcd2ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::const_iterator <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gafc9359c413a6fff9d9c12bd45ca81dfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::const_iterator <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00193.html#aa3519152398319a8c8db877d565bdd01">size_type</a>&#160;</td>
          <td class="paramname"><em>grow</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4914e60d4ae3251d332a27b367b16280"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::iterator <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00193.html#aa3519152398319a8c8db877d565bdd01">size_type</a>&#160;</td>
          <td class="paramname"><em>grow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6a680e2548b56a7dadc9f0269fd2bb7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::IndexMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac38c2a9d650c270b58a6572b8d54292f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00193.html#aa3519152398319a8c8db877d565bdd01">size_type</a>&#160;</td>
          <td class="paramname"><em>grow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>.</p>

</div>
</div>
<a class="anchor" id="gad629dd82634eee7d4b4eb66f261d316f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicVector&lt; K &gt; &amp; <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::lhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local left hand side. </p>
<dl class="section return"><dt>Returns:</dt><dd>The local left hand side. </dd></dl>

</div>
</div>
<a class="anchor" id="gab12ab6a6a059d8ebb057b245e0d8b279"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::field_type * <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::lhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local left hand side. </p>
<dl class="section return"><dt>Returns:</dt><dd>The local left hand side. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f21fa6a8c50e4281aac39aa06ed442c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">X &amp; <a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::lhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local left hand side. </p>
<dl class="section return"><dt>Returns:</dt><dd>The local left hand side. </dd></dl>

</div>
</div>
<a class="anchor" id="ga269a3355821d51265d5c78fa2b411b2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00178.html">Dune::MultiplicativeAdder</a>&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::MultiplicativeAdder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00046.html">BlockVector</a>&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00046.html">BlockVector</a>&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00187.html">OverlappingAssigner</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>assigner_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>relax_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadd589bdc2211809ea5aeead12650c076"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00188.html#a8680d12ef4e7de157d04105bb77f72af">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domainIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate one entry of the local defect. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainIndex</td><td>One index of the domain. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>, and <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>.</p>

</div>
</div>
<a class="anchor" id="gacf6930cc9d03fc7b978c36362d4238dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00191.html#a1e957b97f0d50d7bae829d228eca12ca">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate one entry of the local defect. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>One index of the domain. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>, and <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>.</p>

</div>
</div>
<a class="anchor" id="ga85a5a216087e03197a0b64f7484bccb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00192.html#a2481bf0db19cb556ec7388eb171d2056">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate one entry of the local defect. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>One index of the domain. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00369.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>, and <a class="el" href="a00369.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>.</p>

</div>
</div>
<a class="anchor" id="ga638ab5d22970e302b0bf78a0baa11199"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">Dune::AdditiveAdder</a>&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00008.html#a7355863493dfd0e8a57516d11865bb51">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa4dab85e4fba47077cb0142e759bd60e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00178.html">Dune::MultiplicativeAdder</a>&lt; S, BlockVector&lt; FieldVector&lt; T, n &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00179.html#a2d68e5969be435aa1a9352a772794710">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab05914b838ce44fe41e06af143a46c76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::OverlappingAssigner </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>b_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>x_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlength</td><td>The maximum entries over all subdomains. </td></tr>
    <tr><td class="paramname">mat_</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">b_</td><td>the global right hand side. </td></tr>
    <tr><td class="paramname">x_</td><td>the global left hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f99e68fe280cd951b063c5034f7f055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::OverlappingAssigner </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00040.html">BCRSMatrix</a>&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00191.html#a644e3328b247a59df2f8da7077a01864">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00191.html#a644e3328b247a59df2f8da7077a01864">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlength</td><td>The maximum entries over all subdomains. </td></tr>
    <tr><td class="paramname">mat</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">b</td><td>the global right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>the global left hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a24b7bf122f654480690478c2cc80fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::OverlappingAssignerILUBase </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlength</td><td>The maximum entries over all subdomains. </td></tr>
    <tr><td class="paramname">mat</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">b</td><td>the global right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>the global left hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga680ecf80821212aaa8149d72eea3010e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00193.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::OverlappingSchwarzInitializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00193.html#abec4859ff0228c9b8af3095b41cb8b0a">InitializerList</a> &amp;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00193.html#a4720a7ee7e9cb7069df83bcb38bcbcee">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00193.html#ae876d38e035d6edaae28a4ff0ffd59ac">subdomain_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>domains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga020550e60276e3d02fcaa0a7cccdeb7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::relaxResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00188.html#af34ab7e99507bfa02c6d6baa9e03ac2b">field_type</a>&#160;</td>
          <td class="paramname"><em>relax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>relax the result. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">relax</td><td>The relaxation parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0367fbcb988b7065acc5c3960f48ef3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::relaxResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00191.html#ab3652a9ff263e425e3a6418ed2aa6c8b">field_type</a>&#160;</td>
          <td class="paramname"><em>relax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>relax the result. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">relax</td><td>The relaxation parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad711654fd4e5f5e86f68e99795664119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::relaxResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00192.html#a7a8f220648705f76494c29ec41e5340f">field_type</a>&#160;</td>
          <td class="paramname"><em>relax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>relax the result. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">relax</td><td>The relaxation parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4621a7b0691f6ead344f601601c2fc77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::resetIndexForNextDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the local index to zero. </p>

</div>
</div>
<a class="anchor" id="ga0746cf89c885736ae33cdb6f002b1b13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::resetIndexForNextDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4236f7c9f4d06105d1f2f2f4ded2ea95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::resetIndexForNextDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the local index to zero. </p>

</div>
</div>
<a class="anchor" id="gad0f8311457761bea12f65864eb22a0a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int n, class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicVector&lt; K &gt; &amp; <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; FieldMatrix&lt; K, n, n &gt;, Al &gt;, X, Y &gt; &gt;::rhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local right hand side. </p>
<dl class="section return"><dt>Returns:</dt><dd>The local right hand side. </dd></dl>

</div>
</div>
<a class="anchor" id="ga15694420b9015b1fbd603996e4a24f0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OverlappingAssigner&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::field_type * <a class="el" href="a00187.html">Dune::OverlappingAssigner</a>&lt; SuperLU&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, <a class="el" href="a00369.html#gaaf9526ceb06c2a3425a0d91eec5dffe8">A</a> &gt; &gt; &gt;::rhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local right hand side. </p>
<dl class="section return"><dt>Returns:</dt><dd>The local right hand side. </dd></dl>

</div>
</div>
<a class="anchor" id="ga242dba5b5b746420469c028df5833224"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Y &amp; <a class="el" href="a00192.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::rhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local right hand side. </p>
<dl class="section return"><dt>Returns:</dt><dd>The local right hand side. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b6f1eb9ad0a1080f762446c800ee2ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class TM , class TD , class TA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00235.html">Dune::SeqOverlappingSchwarz</a>&lt; M, X, TM, TD, TA &gt;::SeqOverlappingSchwarz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00235.html#a2c1e4ea9fee09a79b7aaf1b2b3c4d0d2">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00235.html#a818ef7d06d95a0cc065d99c293acce71">subdomain_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>subDomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00235.html#a00ba249b6b77136bb153c46347b389b9">field_type</a>&#160;</td>
          <td class="paramname"><em>relaxationFactor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly_</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the overlapping Schwarz method. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to precondition. </td></tr>
    <tr><td class="paramname">subDomains</td><td>Array of sets of rowindices belonging to an overlapping subdomain </td></tr>
    <tr><td class="paramname">relaxationFactor</td><td>relaxation factor </td></tr>
    <tr><td class="paramname">onTheFly_</td><td>If true the decomposition of the exact local solvers is computed on the fly for each subdomain and iteration step. If false all decompositions are computed in pre and only forward and backward substitution takes place in the iteration steps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Each rowindex should be part of at least one subdomain! </dd></dl>

<p>References <a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>.</p>

</div>
</div>
<a class="anchor" id="gae92d3496d89061727cbb287f66353cb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class TM , class TD , class TA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00235.html">Dune::SeqOverlappingSchwarz</a>&lt; M, X, TM, TD, TA &gt;::SeqOverlappingSchwarz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00235.html#a2c1e4ea9fee09a79b7aaf1b2b3c4d0d2">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00235.html#aae89b344d87fcbd252c51c4caece9f89">rowtodomain_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00235.html#a00ba249b6b77136bb153c46347b389b9">field_type</a>&#160;</td>
          <td class="paramname"><em>relaxationFactor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly_</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the overlapping Schwarz method </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to precondition. </td></tr>
    <tr><td class="paramname">rowToDomain</td><td>The mapping of the rows onto the domains. </td></tr>
    <tr><td class="paramname">relaxationFactor</td><td>relaxation factor </td></tr>
    <tr><td class="paramname">onTheFly_</td><td>If true the decomposition of the exact local solvers is computed on the fly for each subdomain and iteration step. If false all decompositions are computed in pre and only forward and backward substitution takes place in the iteration steps. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00369.html#ga7d32db6cd3c5ac74d8520acfe4df1141">row</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 4 2012 12:02:18 for dune-istl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
